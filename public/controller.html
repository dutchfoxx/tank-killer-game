<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Controller - Tank Killer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: 
                linear-gradient(135deg, 
                    #2a2a2a 0%, 
                    #3a3a3a 25%, 
                    #2a2a2a 50%, 
                    #1a1a1a 75%, 
                    #2a2a2a 100%),
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 50%);
            background-blend-mode: overlay;
            color: #FFFFFF;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.02) 2px,
                    rgba(255, 255, 255, 0.02) 4px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.03) 2px,
                    rgba(0, 0, 0, 0.03) 4px
                );
            pointer-events: none;
            z-index: 0;
        }

        body.damage-feedback {
            background-color: #b83400;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/green-dust-and-scratches.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.3;
            z-index: -1;
            pointer-events: none;
        }

        /* Join State */
        .join-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .join-form {
            background-color: #1b1b1b;
            padding: 30px;
            border-radius: 15px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            z-index: 10;
        }

        .join-form h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #b83400;
            font-size: 1.8rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #CCCCCC;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background-color: #555555;
            color: #FFFFFF;
            font-size: 16px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #b83400;
        }

        .base-color-options {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .base-color-option {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .base-color-option:hover {
            transform: scale(1.1);
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .base-color-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .base-color-option.custom {
            font-size: 18px;
            color: #333;
            text-shadow: none;
            background: linear-gradient(45deg, #ccc, #999) !important;
            border: 2px dashed #666;
        }

        /* Special metallic gradient for Metal color */
        .base-color-option[data-color="#6a6a6a"] {
            background: radial-gradient(circle at 30% 30%, #8a8a8a, #6a6a6a, #4a4a4a) !important;
        }

        .callname-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .generate-name-btn {
            position: absolute;
            right: 0px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 8px;
            transition: color 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .generate-name-btn.active {
            color: #fff;
        }

        .callname-container input {
            padding-right: 48px;
        }

        .selection-name {
            font-weight: normal;
            opacity: 0.8;
        }

        .base-color-name {
            font-size: 8px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            z-index: 1;
            position: relative;
        }

        .color-wheel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .color-wheel-container {
            background: #333;
            border-radius: 10px;
            padding: 20px;
            position: relative;
        }

        .color-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080, #ff0000);
            position: relative;
            cursor: crosshair;
        }

        .color-wheel::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            background: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .color-wheel-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid #000;
            border-radius: 50%;
            pointer-events: none;
        }

        .color-wheel-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #666;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
        }

        .tank-preview-container {
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .tank-preview-canvas {
            width: 100%;
            height: 120px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: #444;
            display: block;
        }

        .camo-options {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .camo-option {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.8s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            background-color: var(--base-color);
        }

        .camo-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--base-color);
            background-image: var(--texture-url);
            background-repeat: repeat;
            background-size: calc(100px * var(--texture-scale));
            opacity: var(--texture-opacity);
            background-blend-mode: var(--texture-blend-mode);
            border-radius: 4px;
            pointer-events: none;
            transition: background-color 0.8s ease;
        }

        .camo-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .camo-option.none {
            background-color: var(--base-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #666;
        }

        .camo-name {
            font-size: 6px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            z-index: 1;
            position: relative;
        }

        .team-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .team-option {
            width: 100%;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .team-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .team-badge {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            object-fit: contain;
        }

        .join-button {
            width: 100%;
            padding: 15px;
            background-color: #b83400;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .join-button:hover {
            background-color: #a03000;
        }

        .join-button:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }

        /* Play State */
        .play-state {
            flex: 1;
            display: none;
            flex-direction: column;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10;
            overflow-y: auto;
            padding: 5px;
            box-sizing: border-box;
        }

        .play-state.active {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Remove background-blend-mode when in play mode */
        .play-state.active ~ body,
        body.play-mode {
            background-blend-mode: normal;
        }

        /* Restore background-blend-mode when not in play mode */
        body:not(.play-mode) {
            background-blend-mode: overlay;
        }

        /* Attribute Banner */
        .attribute-banner {
            background-color: #1b1b1b;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            border: 3px solid #111;
            border-radius: 0px;
            box-shadow: inset 0 0 10px #000, 0 4px 10px rgba(0, 0, 0, 0.7), 0 -2px 6px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .attribute-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/brushed-alum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.1;
            z-index: 0;
            pointer-events: none;
        }

        .attribute-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 60px;
            max-width: 80px;
        }

        .attribute-label {
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            margin-bottom: 5px;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attribute-bar {
            width: 100%;
            height: 22px;
            background: #111;
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 6px #000;
            display: flex;
            align-items: flex-start;
        }

        .attribute-fill {
            height: 80%;
            margin-top: 2px;
            background: linear-gradient(90deg, #ffe066, #ffcc33);
            border-right: 2px solid #f5e087;
            box-shadow: inset 0 0 4px #000, 0 0 6px #ffcc33;
            transition: width 0.3s ease;
        }

        .attribute-fill.health { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.speed { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.rotation { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.kinetics { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }

        .attribute-value {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffcc33;
            background: linear-gradient(to bottom, #1c1c1c, #0a0a0a);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            text-shadow: 
                0 0 2px #ffcc33,
                0 0 4px #ffcc33;
            text-align: center;
            width: 50px;
            min-width: 50px;
            max-width: 50px;
            margin-top: 3px;
        }

        /* Alarm Lights */
        .alarm-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid;
            display: inline-block;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* Alarm ON */
        .alarm-on {
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            border-color: #660000;
            box-shadow:
                0 0 8px 2px #ff1a1a,
                inset 0 0 3px #ff6666,
                0 0 12px 3px rgba(255, 0, 0, 0.5);
            animation: blink 1s infinite alternate;
        }

        /* Alarm OFF */
        .alarm-off {
            background: radial-gradient(circle at 30% 30%, #666, #333);
            border-color: #555;
            box-shadow:
                inset 0 0 2px #222,
                0 0 1px #000;
        }

        /* Blinking Animation */
        @keyframes blink {
            0% {
                box-shadow:
                    0 0 4px 1px #ff1a1a,
                    inset 0 0 2px #ff3333,
                    0 0 8px 2px rgba(255, 0, 0, 0.3);
                background: radial-gradient(circle at 30% 30%, #cc0000, #660000);
            }
            100% {
                box-shadow:
                    0 0 12px 3px #ff1a1a,
                    inset 0 0 4px #ff9999,
                    0 0 16px 4px rgba(255, 0, 0, 0.7);
                background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            }
        }

        /* Fast Blinking Animation for Critical Levels */
        @keyframes blinkCritical {
            0% {
                box-shadow:
                    0 0 4px 1px #ff1a1a,
                    inset 0 0 2px #ff3333,
                    0 0 8px 2px rgba(255, 0, 0, 0.3);
                background: radial-gradient(circle at 30% 30%, #cc0000, #660000);
            }
            100% {
                box-shadow:
                    0 0 12px 3px #ff1a1a,
                    inset 0 0 4px #ff9999,
                    0 0 16px 4px rgba(255, 0, 0, 0.7);
                background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            }
        }

        /* Alarm Flashing Animation */
        .alarm-flashing {
            animation: blink 1s infinite alternate;
        }

        /* Critical Alarm Flashing Animation - Faster */
        .alarm-critical {
            animation: blinkCritical 0.3s infinite alternate;
        }

        /* Game Controls */
        .game-controls {
            padding: 20px;
            text-align: center;
        }

        /* Fire Button */
        .fire-button-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-left: 50px;
        }

        .fire-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4a0000, #1a0000);
            border: 3px solid #110000;
            color: #e6d0d0;
            font-size: 26px;
            font-family: 'Black Ops One', monospace;
            font-weight: normal;
            cursor: pointer;
            box-shadow:
                inset 1px 1px 2px #300000,
                inset -1px -1px 3px #000,
                0 2px 4px rgba(0, 0, 0, 0.6);
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #000,
                0 0 2px #600;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
            position: relative;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            background-blend-mode: multiply;
            filter: contrast(120%) brightness(90%);
        }



        .fire-button:active {
            transform: translateY(1px);
        }

        .fire-button.fire-glow {
            background: radial-gradient(circle at 30% 30%, #8b0000, #660000);
            box-shadow:
                inset 2px 2px 3px #000,
                0 1px 2px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(139, 0, 0, 0.6),
                0 0 30px rgba(139, 0, 0, 0.3);
            animation: fireGlow 0.8s ease-out;
        }

        @keyframes fireGlow {
            0% {
                background: radial-gradient(circle at 30% 30%, #8b0000, #660000);
                box-shadow:
                    inset 2px 2px 3px #000,
                    0 1px 2px rgba(0, 0, 0, 0.3),
                    0 0 15px rgba(139, 0, 0, 0.6),
                    0 0 30px rgba(139, 0, 0, 0.3);
            }
            50% {
                background: radial-gradient(circle at 30% 30%, #730000, #520000);
                box-shadow:
                    inset 2px 2px 3px #000,
                    0 1px 2px rgba(0, 0, 0, 0.3),
                    0 0 12px rgba(139, 0, 0, 0.4),
                    0 0 25px rgba(139, 0, 0, 0.2);
            }
            100% {
                background: radial-gradient(circle at 30% 30%, #4a0000, #1a0000);
                box-shadow:
                    inset 1px 1px 2px #300000,
                    inset -1px -1px 3px #000,
                    0 2px 4px rgba(0, 0, 0, 0.6);
            }
        }

        .fire-button:disabled {
            background: linear-gradient(to bottom, #666666 0%, #444444 100%);
            border-color: #333333;
            color: #999999;
            cursor: not-allowed;
            box-shadow:
                0 6px #333333,
                inset 0 0 6px #555555;
        }

        /* Wear overlay */
        .fire-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(135deg, rgba(255, 255, 255, 0.025) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.025) 50%, rgba(255, 255, 255, 0.025) 75%, transparent 75%, transparent);
            background-size: 4px 4px, 8px 8px;
            opacity: 0.3;
            z-index: 2;
        }

        /* 60-lines texture overlay */
        .fire-button::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/60-lines.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 1;
            z-index: 1;
            pointer-events: none;
            border-radius: 50%;
        }

        .ammo-label {
            font-size: 0.9rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow:
                0 1px 0 #111,
                0 -1px 1px #666,
                0 0 1px #000;
            text-align: center;
        }

        .fire-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .ammo-label {
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            margin-bottom: 1px;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .ammunition-display {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            font-weight: bold;
            color: #ffcc33;
            background: linear-gradient(to bottom, #1c1c1c, #0a0a0a);
            padding: 4px 14px;
            border-radius: 8px;
            border: 1px solid #444;
            text-shadow: 
                0 0 3px #ffcc33,
                0 0 6px #ffcc33;
            text-align: center;
            width: 60px;
            min-width: 60px;
            max-width: 60px;
            z-index: 1;
        }

        /* Joystick */
        .joystick-container {
            position: relative;
            width: 200px;
            height: 200px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            margin: 0 auto;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #3a3a3a;
            border: 3px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: inset 0 0 12px #1a1a1a;
        }

        .joystick-base::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/light-aluminum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.2;
            z-index: 0;
            pointer-events: none;
            border-radius: 50%;
        }

        .joystick-center {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #111;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .joystick-stick {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #462e2e, #000000);
            box-shadow:
                inset -3px -3px 6px rgba(255, 255, 255, 0.1),
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            cursor: pointer;
            transition: transform 0.05s ease-out;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .joystick-stick::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/dark-leather.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 1;
            z-index: 0;
            pointer-events: none;
            border-radius: 50%;
        }

        /* Status Messages */
        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1b1b1b;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        }

        /* Gasoline HUD */
        #gasolineHUD {
            position: relative;
            width: 280px;
            height: 70px;
            background: #2a2a2a;
            border: 3px solid #111;
            border-radius: 10px;
            box-shadow:
                inset 0 0 10px #000,
                0 4px 10px rgba(0,0,0,0.7),
                0 -2px 6px rgba(255,255,255,0.1);
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            z-index: 1000;
            margin: 0 auto 20px auto;
        }

        #gasolineHUD::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/brushed-alum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.2;
            z-index: -1;
            pointer-events: none;
        }

        .gasoline-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 38px;
            color: rgba(156, 29, 29, 0.08);
            transition: color 0.3s ease, filter 0.3s ease;
            z-index: 1;
            text-shadow:
                0 1px 1px #161010,
                0 -1px 1px #181212,
                -1px 0 1px #929292,
                1px 0 1px #c0c0c0,
                0 0 5px rgba(58, 47, 47, 0.2);
            filter: none;
        }

        .icon-on {
            color: #9c1d1d;
            filter: drop-shadow(0 0 4px rgba(156, 29, 29, 0.3)) drop-shadow(0 0 10px rgba(156, 29, 29, 0.2));
        }

        .icon-flashing {
            animation: flash 1s infinite alternate;
        }

        @keyframes flash {
            from {
                color: rgba(156, 29, 29, 0.3);
                filter: drop-shadow(0 0 4px rgba(156, 29, 29, 0.2));
            }
            to {
                color: #9c1d1d;
                filter: drop-shadow(0 0 6px rgba(156, 29, 29, 0.6)) drop-shadow(0 0 12px rgba(156, 29, 29, 0.8));
            }
        }

        .gasoline-bar {
            position: absolute;
            top: 40%;
            left: 64px;
            transform: translateY(-50%);
            width: 190px;
            height: 22px;
            background: #111;
            border: 2px solid #444;
            border-radius: 4px;
            box-shadow: inset 0 0 6px #000;
            display: flex;
            align-items: flex-start;
            z-index: 2;
        }

        .gasoline-fill {
            height: 80%;
            margin-top: 2px;
            background: linear-gradient(90deg, #ffe066, #ffcc33);
            border-right: 2px solid #f5e087;
            box-shadow: inset 0 0 4px #000, 0 0 6px #ffcc33;
            transition: width 0.3s ease;
        }

        .gasoline-label {
            position: absolute;
            bottom: 10px;
            right: 20px;
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            z-index: 2;
        }

        .status-message.show {
            display: block;
        }

        /* Bolt styling */
        .bolt {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #888, #2a2a2a);
            box-shadow:
                inset -1px -1px 2px rgba(255, 255, 255, 0.1),
                inset 1px 1px 3px rgba(0, 0, 0, 0.6),
                0 0 2px rgba(0, 0, 0, 0.4);
            position: absolute;
            border: 1px solid #3c3a3a;
            filter: contrast(110%) brightness(90%);
        }

        .bolt::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        .bolt::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(-45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        /* Attribute banner bolts - darker metallic */
        .attribute-bolt {
            background: radial-gradient(circle at 30% 30%, #444, #111);
            border: 1px solid #1a1a1a;
            filter: contrast(120%) brightness(70%);
        }

        .attribute-bolt::before, .attribute-bolt::after {
            background: linear-gradient(to right, #111, #333, #111);
            box-shadow: 
                inset 0.5px 0 0.5px #555,
                inset -0.5px 0 0.5px #111;
        }

        /* Background bolts */
        .background-bolt {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #888, #2a2a2a);
            box-shadow:
                inset -1px -1px 2px rgba(255, 255, 255, 0.1),
                inset 1px 1px 3px rgba(0, 0, 0, 0.6),
                0 0 2px rgba(0, 0, 0, 0.4);
            position: absolute;
            border: 1px solid #3c3a3a;
            filter: contrast(110%) brightness(90%);
            z-index: 1;
        }

        .background-bolt::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 1px;
            background: linear-gradient(to right, #000, #444, #000);
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #666,
                inset -0.5px 0 0.5px #222;
        }

        .background-bolt::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 1px;
            background: linear-gradient(to right, #000, #444, #000);
            transform: translate(-50%, -50%) rotate(-45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #666,
                inset -0.5px 0 0.5px #222;
        }

        .status-message.success {
            background-color: #4CAF50;
        }

        .status-message.error {
            background-color: #F44336;
        }

        @media (max-width: 480px) {
            .join-form {
                padding: 20px;
                margin: 10px;
            }

            .fire-button {
                width: 100px;
                height: 100px;
                font-size: 20px;
            }

            .joystick-container {
                width: 150px;
                height: 150px;
            }

            .joystick-stick {
                width: 50px;
                height: 50px;
            }

            .attribute-banner {
                padding: 10px;
            }

            .attribute-item {
                min-width: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="background-bolt" style="top: 110px; left: 20px;"></div>
        <div class="background-bolt" style="top: 110px; right: 20px;"></div>
        <div class="background-bolt" style="bottom: 20px; left: 20px;"></div>
        <div class="background-bolt" style="bottom: 20px; right: 20px;"></div>
        <!-- Join State -->
        <div class="join-state" id="joinState" style="display: flex;">
            <div class="join-form">

                <!-- Tank Preview -->
                <div class="tank-preview-container">
                    <canvas id="tankPreview" class="tank-preview-canvas"></canvas>
                </div>

                <div class="form-group">
                    <label for="callname">Callname</label>
                    <div class="callname-container">
                        <input type="text" id="callname" placeholder="Enter your callname" maxlength="15">
                        <button type="button" id="generateName" class="generate-name-btn" title="Generate random name">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Tank colour: <span id="selectedColorName" class="selection-name">Forest</span></label>
                    <div class="base-color-options" id="baseColorOptions">
                        <!-- Base color options will be dynamically generated -->
                    </div>
                </div>

                <div class="form-group">
                    <label>Camo: <span id="selectedCamoName" class="selection-name">None</span></label>
                    <div class="camo-options" id="camoOptions">
                        <!-- Camo options will be dynamically generated -->
                    </div>
                </div>

                <div class="form-group">
                    <label>Team:</label>
                    <div class="team-options">
                        <div class="team-option selected" data-team="NATO" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-nato.png" alt="NATO" class="team-badge">
                            <span>NATO</span>
                        </div>
                        <div class="team-option" data-team="CSTO" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-csto.png" alt="CSTO" class="team-badge">
                            <span>CSTO</span>
                        </div>
                        <div class="team-option" data-team="PLA" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-pla.png" alt="PLA" class="team-badge">
                            <span>PLA</span>
                        </div>
                    </div>
                </div>

                <button class="join-button" id="joinButton">Join Game</button>
            </div>
        </div>

        <!-- Play State -->
        <div class="play-state" id="playState">
            <!-- Attribute Banner -->
            <div class="attribute-banner">
                <div class="bolt attribute-bolt" style="top: 1px; left: 1px;"></div>
                <div class="bolt attribute-bolt" style="top: 1px; right: 1px;"></div>
                <div class="bolt attribute-bolt" style="bottom: 1px; left: 1px;"></div>
                <div class="bolt attribute-bolt" style="bottom: 1px; right: 1px;"></div>
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="healthAlarm"></span>
                        HEALTH
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill health" id="healthBar"></div>
                    </div>
                    <div class="attribute-value" id="healthValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="speedAlarm"></span>
                        SPEED
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill speed" id="speedBar"></div>
                    </div>
                    <div class="attribute-value" id="speedValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="rotationAlarm"></span>
                        ROTATION
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill rotation" id="rotationBar"></div>
                    </div>
                    <div class="attribute-value" id="rotationValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="kineticsAlarm"></span>
                        KINETICS
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill kinetics" id="kineticsBar"></div>
                    </div>
                    <div class="attribute-value" id="kineticsValue">100%</div>
                </div>
            </div>

            <!-- Gasoline HUD -->
            <div id="gasolineHUD" class="gasoline-container">
                <div class="bolt" style="top: 5px; left: 5px;"></div>
                <div class="bolt" style="top: 5px; right: 5px;"></div>
                <div class="bolt" style="bottom: 5px; left: 5px;"></div>
                <div class="bolt" style="bottom: 5px; right: 5px;"></div>
                <span class="material-icons gasoline-icon" id="gasIcon">local_gas_station</span>
                <div class="gasoline-bar">
                    <div class="gasoline-fill" id="gasFill"></div>
                </div>
                <div class="gasoline-label">GASOLINE</div>
            </div>

            <!-- Game Controls -->
            <div class="game-controls">
                <!-- Fire Controls -->
                <div class="fire-controls">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="ammo-label">AMMO</div>
                        <div class="ammunition-display" id="ammunitionDisplay">14</div>
                    </div>
                    <button class="fire-button" id="fireButton">
                        FIRE
                    </button>
                </div>

                <!-- Joystick -->
                <div class="joystick-container" id="joystickContainer">
                    <div class="joystick-base">
                        <div class="joystick-center"></div>
                        <div class="joystick-stick" id="joystickStick"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Message -->
    <div class="status-message" id="statusMessage"></div>

    <!-- Shared Tank Colors Configuration -->
    <script src="/src/shared/tankColors.js"></script>
    <script src="/src/shared/tankCamo.js"></script>
    <script src="/src/shared/shadows.js"></script>
    <script src="/src/shared/defaultNames.js"></script>

    <script>
        // Removed excessive debug logging for better performance
        
        // Game state
        let playerState = null;
        let isConnected = false;
        let selectedColor = '#1f2e23';
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickPosition = { x: 0, y: 0 };
        let inputInterval = null;

        // DOM elements
        const joinState = document.getElementById('joinState');
        const playState = document.getElementById('playState');
        const callnameInput = document.getElementById('callname');
        const joinButton = document.getElementById('joinButton');
        const fireButton = document.getElementById('fireButton');
        const ammunitionDisplay = document.getElementById('ammunitionDisplay');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');
        const statusMessage = document.getElementById('statusMessage');
        
        // Removed excessive debug logging for better performance

        // Socket connection
        const socket = io();

        // Game state variables
        let selectedBaseColor = '#1f2e23';
        let selectedCamo = 'none';
        let selectedTeam = 'NATO';

        // Robust random selection functions
        function selectRandomTeam() {
            const teams = ['NATO', 'CSTO', 'PLA'];
            return teams[Math.floor(Math.random() * teams.length)];
        }
        
        function selectRandomName(team) {
            const randomRank = ranks[Math.floor(Math.random() * ranks.length)];
            const teamNames = defaultNames[team] || defaultNames.NATO;
            const randomName = teamNames[Math.floor(Math.random() * teamNames.length)];
            return `${randomRank} ${randomName}`;
        }
        
        function selectRandomColor() {
            const colorKeys = Object.keys(tankColors).filter(key => key !== 'custom');
            const randomKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
            return {
                key: randomKey,
                color: tankColors[randomKey]
            };
        }
        
        function selectRandomCamo() {
            const camoKeys = Object.keys(tankCamos);
            const randomKey = camoKeys[Math.floor(Math.random() * camoKeys.length)];
            return {
                key: randomKey,
                camo: tankCamos[randomKey]
            };
        }
        
        function randomizeEverything() {
            // Removed excessive debug logging for better performance
            
            // 1. Randomize team first
            selectedTeam = selectRandomTeam();
            
            // 2. Generate random name based on team
            const randomCallname = selectRandomName(selectedTeam);
            callnameInput.value = randomCallname;
            
            // 3. Randomize color BEFORE camo (so camo can blend properly)
            const randomColorData = selectRandomColor();
            selectedBaseColor = randomColorData.color.hex;
            
            // 4. Randomize camo AFTER color (so it can blend with the selected color)
            const randomCamoData = selectRandomCamo();
            selectedCamo = randomCamoData.key;
            
            // 5. Update UI with proper order
            updateUIWithSelections();
        }
        
        // Robust UI update function
        function updateUIWithSelections() {
            // Removed excessive debug logging for better performance
            
            // Update team selection
            const teamOptions = document.querySelectorAll('.team-option');
            teamOptions.forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.team === selectedTeam) {
                    option.classList.add('selected');
                }
            });
            
            // Update color selection
            const colorOptions = document.querySelectorAll('.base-color-option');
            colorOptions.forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.color === selectedBaseColor) {
                    option.classList.add('selected');
                    const colorName = document.getElementById('selectedColorName');
                    if (colorName) {
                        colorName.textContent = option.dataset.name;
                    }
                }
            });
            
            // Update camo selection
            const camoOptions = document.querySelectorAll('.camo-option');
            camoOptions.forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.camo === selectedCamo) {
                    option.classList.add('selected');
                    const camoName = document.getElementById('selectedCamoName');
                    if (camoName) {
                        camoName.textContent = option.dataset.name;
                    }
                }
            });
            
            // Update camo backgrounds and preview
            updateCamoBackgrounds();
            loadCamoImages();
        }

        // Tank preview variables
        let tankBodyContours = null;
        let tankBodyColorMap = null;
        let tankTurretContours = null;
        let tankTurretBaseColorMap = null;
        let tankTurretGunneryColorMap = null;
        let camoBaseImage = null;
        let camoTurretImage = null;

        // Generate random name functionality
        const generateNameBtn = document.getElementById('generateName');
        
        function generateRandomName() {
            const randomRank = ranks[Math.floor(Math.random() * ranks.length)];
            const teamNames = defaultNames[selectedTeam] || defaultNames.NATO;
            const randomName = teamNames[Math.floor(Math.random() * teamNames.length)];
            return `${randomRank} ${randomName}`;
        }

        generateNameBtn.addEventListener('click', () => {
            const randomName = generateRandomName();
            callnameInput.value = randomName;
            
            // Add active state
            generateNameBtn.classList.add('active');
            
            // Remove active state after 200ms
            setTimeout(() => {
                generateNameBtn.classList.remove('active');
            }, 200);
        });

        // Initialize UI elements
        function initializeUI() {
            // Generate base color options
            const baseColorContainer = document.getElementById('baseColorOptions');
            
            // Check if tankColors is available
            if (typeof tankColors === 'undefined') {
                console.error('tankColors is not defined! Check if tankColors.js is loading correctly.');
                return;
            }
            
            // Removed excessive debug logging for better performance
            
            // Create color squares for each tank color
            Object.entries(tankColors).forEach(([key, color]) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'base-color-option';
                colorOption.style.backgroundColor = color.hex;
                colorOption.dataset.color = color.hex;
                colorOption.dataset.name = color.label;
                colorOption.dataset.key = key;
                
                // Add click event
                colorOption.addEventListener('click', () => {
                    document.querySelectorAll('.base-color-option').forEach(opt => opt.classList.remove('selected'));
                    colorOption.classList.add('selected');
                    selectedBaseColor = color.hex;
                    
                    // Update color name display
                    document.getElementById('selectedColorName').textContent = color.label;
                    
                    updateCamoBackgrounds();
                    updateTankPreview();
                });
                
                baseColorContainer.appendChild(colorOption);
            });

            // Add custom color picker square
            const customColorOption = document.createElement('div');
            customColorOption.className = 'base-color-option custom';
            customColorOption.dataset.color = '#ff0000';
            customColorOption.dataset.name = 'Custom';
            customColorOption.dataset.key = 'custom';
            customColorOption.innerHTML = '<span>+</span>';
            
            // Add click event for custom color picker
            customColorOption.addEventListener('click', () => {
                showColorWheel();
            });
            
            baseColorContainer.appendChild(customColorOption);

            // Initialize custom color in tankColors if it doesn't exist
            if (!tankColors.custom) {
                tankColors.custom = '#ff0000';
            }

            // Generate camo options
            const camoContainer = document.getElementById('camoOptions');
            
            // Check if tankCamos is available
            if (typeof tankCamos === 'undefined') {
                console.error('tankCamos is not defined! Check if tankCamo.js is loading correctly.');
                return;
            }
            
            // Removed excessive debug logging for better performance
            
            Object.entries(tankCamos).forEach(([key, config]) => {
                const camoOption = document.createElement('div');
                camoOption.className = 'camo-option';
                camoOption.dataset.camo = key;
                camoOption.dataset.name = config.name;
                camoOption.dataset.texture = config.texture;
                camoOption.dataset.opacity = config.opacity;
                camoOption.dataset.scale = config.scale;
                
                // Handle "none" camo option
                if (key === 'none') {
                    camoOption.classList.add('none');
                    camoOption.textContent = '';
                    camoOption.style.setProperty('--texture-url', 'none');
                    camoOption.style.setProperty('--texture-opacity', '0');
                } else {
                    // Set CSS variables for texture
                    camoOption.style.setProperty('--texture-url', `url('/assets/images/${config.texture}')`);
                    camoOption.style.setProperty('--texture-opacity', config.opacity);
                    camoOption.style.setProperty('--texture-scale', config.scale);
                    camoOption.style.setProperty('--texture-blend-mode', config.blendMode || 'auto');
                }
                
                // Add click event
                camoOption.addEventListener('click', () => {
                    document.querySelectorAll('.camo-option').forEach(opt => opt.classList.remove('selected'));
                    camoOption.classList.add('selected');
                    selectedCamo = key;
                    
                    // Update camo name display
                    document.getElementById('selectedCamoName').textContent = config.name;
                    
                    // Load new camo images and update preview
                    loadCamoImages();
                });
                
                camoContainer.appendChild(camoOption);
            });
        }
        
        // Load tank images
        function loadTankImages() {
            // Body images
            tankBodyContours = new Image();
            tankBodyContours.onload = () => updateTankPreview();
            tankBodyContours.onerror = () => console.error('Failed to load tank body contours');
            tankBodyContours.src = '/assets/images/tanks/body_contours.png';

            tankBodyColorMap = new Image();
            tankBodyColorMap.onload = () => updateTankPreview();
            tankBodyColorMap.onerror = () => console.error('Failed to load tank body color map');
            tankBodyColorMap.src = '/assets/images/tanks/bodyBase_colourMap.png';

            // Turret images
            tankTurretContours = new Image();
            tankTurretContours.onload = () => updateTankPreview();
            tankTurretContours.onerror = () => console.error('Failed to load tank turret contours');
            tankTurretContours.src = '/assets/images/tanks/turret_contours.png';

            tankTurretBaseColorMap = new Image();
            tankTurretBaseColorMap.onload = () => updateTankPreview();
            tankTurretBaseColorMap.onerror = () => console.error('Failed to load tank turret base color map');
            tankTurretBaseColorMap.src = '/assets/images/tanks/turretBase_colourMap.png';

            tankTurretGunneryColorMap = new Image();
            tankTurretGunneryColorMap.onload = () => updateTankPreview();
            tankTurretGunneryColorMap.onerror = () => console.error('Failed to load tank turret gunnery color map');
            tankTurretGunneryColorMap.src = '/assets/images/tanks/turretGunnery_colourMap.png';
        }

        // Load camo images
        function loadCamoImages() {
            if (selectedCamo === 'none') {
                camoBaseImage = null;
                camoTurretImage = null;
                updateTankPreview();
                return;
            }

            camoBaseImage = new Image();
            camoBaseImage.onload = () => updateTankPreview();
            camoBaseImage.onerror = () => console.error('Failed to load base camo image');
            camoBaseImage.src = `/assets/images/textures/camo/base_${selectedCamo}.png`;

            camoTurretImage = new Image();
            camoTurretImage.onload = () => updateTankPreview();
            camoTurretImage.onerror = () => console.error('Failed to load turret camo image');
            camoTurretImage.src = `/assets/images/textures/camo/turret_${selectedCamo}.png`;
        }

        // Tank preview settings (exact copy from tank designer)
        const previewSettings = {
            tankScale: 0.067,
            zoomLevel: 6.0,
            camoOpacity: 0.8,
            colorBlendMode: 'hard-light-pixel',
            camoBlendMode: 'overlay',
            bodyShadowType: 'STRONG',
            turretShadowType: 'DEFAULT',
            shadowOpacity: 1.0,
            shadowBlur: 8,
            shadowOffsetX: 4,
            shadowOffsetY: 4
        };

        // Update tank preview (exact copy from tank designer)
        function updateTankPreview() {
            const canvas = document.getElementById('tankPreview');
            if (!canvas) return;

            // Set canvas size to match container
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = 120; // Fixed height for consistency

            const ctx = canvas.getContext('2d');
            
            // Make ctx available globally for drawing functions
            window.ctx = ctx;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = previewSettings.tankScale * previewSettings.zoomLevel;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Check if body images are loaded
            if (!tankBodyContours || !tankBodyColorMap) return;

            // Save context
            ctx.save();

            // Draw tank layers in order (back to front) - EXACT COPY FROM TANK DESIGNER
            // 1. Body color map (furthest back)
            drawTankLayer(tankBodyColorMap, centerX, centerY, scale, true, 'body');
            
            // 2. Body camo (if available) - above base, below elements
            if (selectedCamo !== 'none' && camoBaseImage) {
                ctx.save();
                ctx.globalAlpha = previewSettings.camoOpacity;
                
                // Use fixed overlay blend mode (matching tank designer)
                ctx.globalCompositeOperation = previewSettings.camoBlendMode;
                drawCamoLayer(camoBaseImage, centerX, centerY, scale, 'body');
                ctx.restore();
            }
            
            // 3. Body contours
            drawTankLayer(tankBodyContours, centerX, centerY, scale, false, 'body');
            
            // 4. Turret base color map (if available)
            if (tankTurretBaseColorMap) {
                ctx.save();
                ctx.translate(centerX, centerY);
                drawTankLayer(tankTurretBaseColorMap, 0, 0, scale, true, 'turret');
                ctx.restore();
            }
            
            // 5. Turret camo (if available) - above base, below gunnery
            if (selectedCamo !== 'none' && camoTurretImage) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.globalAlpha = previewSettings.camoOpacity;
                
                // Use fixed overlay blend mode (matching tank designer)
                ctx.globalCompositeOperation = previewSettings.camoBlendMode;
                drawCamoLayer(camoTurretImage, 0, 0, scale, 'turret');
                ctx.restore();
            }
            
            // 6. Turret gunnery color map (if available)
            if (tankTurretGunneryColorMap) {
                ctx.save();
                ctx.translate(centerX, centerY);
                drawTankLayer(tankTurretGunneryColorMap, 0, 0, scale, true, 'turret');
                ctx.restore();
            }
            
            // 7. Turret contours (if available)
            if (tankTurretContours) {
                ctx.save();
                ctx.translate(centerX, centerY);
                drawTankLayer(tankTurretContours, 0, 0, scale, false, 'turret');
                ctx.restore();
            }

            ctx.restore();
        }

        // Draw tank layer (exact copy from tank designer)
        function drawTankLayer(image, centerX, centerY, scale, isColorMap = false, layerType = 'body') {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            if (isColorMap) {
                // Apply custom shadow based on layer type and settings (only for color maps)
                if (previewSettings.bodyShadowType !== 'NONE' || previewSettings.turretShadowType !== 'NONE') {
                    const shadowType = layerType === 'body' ? previewSettings.bodyShadowType : previewSettings.turretShadowType;
                    
                    if (shadowType !== 'NONE') {
                        // Apply custom shadow settings (exact from tank designer)
                        window.ctx.shadowColor = 'black';
                        window.ctx.shadowBlur = previewSettings.shadowBlur;
                        window.ctx.shadowOffsetX = previewSettings.shadowOffsetX;
                        window.ctx.shadowOffsetY = previewSettings.shadowOffsetY;
                        window.ctx.globalAlpha = previewSettings.shadowOpacity;
                        window.ctx.globalCompositeOperation = 'multiply';
                    }
                }

                // For color maps, apply pixel-level color manipulation (exact from tank designer)
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                
                // Draw the original image
                tempCtx.drawImage(image, 0, 0);
                
                // Get image data for manipulation
                const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;
                
                // Convert hex color to RGB and HSL
                const targetR = parseInt(selectedBaseColor.slice(1, 3), 16);
                const targetG = parseInt(selectedBaseColor.slice(3, 5), 16);
                const targetB = parseInt(selectedBaseColor.slice(5, 7), 16);
                const targetHsl = rgbToHsl(targetR, targetG, targetB);
                
                // Apply pixel-level color manipulation (hard-light-pixel mode)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // If pixel is not transparent
                        const pixelR = data[i];
                        const pixelG = data[i + 1];
                        const pixelB = data[i + 2];
                        const pixelA = data[i + 3];
                        
                        // Hard-light-pixel blend mode (exact from tank designer)
                        const newR = targetR < 128 ? (2 * pixelR * targetR) / 255 : 255 - (2 * (255 - pixelR) * (255 - targetR)) / 255;
                        const newG = targetG < 128 ? (2 * pixelG * targetG) / 255 : 255 - (2 * (255 - pixelG) * (255 - targetG)) / 255;
                        const newB = targetB < 128 ? (2 * pixelB * targetB) / 255 : 255 - (2 * (255 - pixelB) * (255 - targetB)) / 255;
                        
                        data[i] = Math.max(0, Math.min(255, Math.round(newR)));
                        data[i + 1] = Math.max(0, Math.min(255, Math.round(newG)));
                        data[i + 2] = Math.max(0, Math.min(255, Math.round(newB)));
                        data[i + 3] = pixelA; // Keep original alpha
                    }
                }
                
                // Put the modified image data back
                tempCtx.putImageData(imageData, 0, 0);
                
                // Draw the modified image
                window.ctx.globalCompositeOperation = 'source-over';
                window.ctx.drawImage(tempCanvas, x, y, width, height);
                
            } else {
                // For contours, draw normally preserving transparency
                window.ctx.globalCompositeOperation = 'source-over';
                window.ctx.drawImage(image, x, y, width, height);
            }
            
            // Reset shadow settings after drawing
            window.ctx.shadowColor = 'transparent';
            window.ctx.shadowBlur = 0;
            window.ctx.shadowOffsetX = 0;
            window.ctx.shadowOffsetY = 0;
            window.ctx.globalAlpha = 1.0;
            window.ctx.globalCompositeOperation = 'source-over';
        }

        // Draw camo layer (exact from tank designer)
        function drawCamoLayer(image, centerX, centerY, scale, layerType = 'body') {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            // For camo layers, draw normally preserving transparency and blend mode
            window.ctx.drawImage(image, x, y, width, height);
        }

        // Call initialization
        initializeUI();
        loadTankImages();
        
        // Ensure UI is updated after a delay (fallback)
        setTimeout(() => {
            if (selectedBaseColor && selectedCamo && selectedTeam) {
                // Removed excessive debug logging for better performance
                updateUIWithSelections();
            }
        }, 2000);

        // Function to update camo option backgrounds based on selected base color
        function updateCamoBackgrounds() {
            const camoOptions = document.querySelectorAll('.camo-option');
            const currentColor = selectedBaseColor;
            const isLightColor = isColorLight(currentColor);
            const blendMode = isLightColor ? 'multiply' : 'soft-light';
            
            // Add a slight stagger effect for smoother animation
            camoOptions.forEach((option, index) => {
                setTimeout(() => {
                    option.style.backgroundColor = currentColor;
                    option.style.setProperty('--base-color', currentColor);
                    
                    // Handle auto blend mode for non-none camos
                    const camoKey = option.dataset.camo;
                    if (camoKey !== 'none') {
                        const camoConfig = tankCamos[camoKey];
                        if (camoConfig && camoConfig.blendMode === 'auto') {
                            option.style.setProperty('--texture-blend-mode', blendMode);
                        }
                    }
                }, index * 80); // 80ms delay between each option
            });
        }

        // Initialize camo backgrounds and set initial base color variable
        updateCamoBackgrounds();
        document.querySelectorAll('.camo-option').forEach(option => {
            option.style.setProperty('--base-color', selectedBaseColor);
        });

        // Team selection
        document.querySelectorAll('.team-option').forEach(option => {
            option.addEventListener('click', () => {
                // Removed excessive debug logging for better performance
                document.querySelectorAll('.team-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedTeam = option.dataset.team;
            });
        });

        // Initialize selections (will be overridden by load logic)
        function initializeSelections() {
            // Select first color, camo, and team by default (fallback)
            const firstColor = document.querySelector('.base-color-option');
            const firstCamo = document.querySelector('.camo-option');
            const firstTeam = document.querySelector('.team-option');
            
            if (firstColor) firstColor.classList.add('selected');
            if (firstCamo) firstCamo.classList.add('selected');
            if (firstTeam) firstTeam.classList.add('selected');
        }

        // Join game
        joinButton.addEventListener('click', () => {
            // Removed excessive debug logging for better performance
            const callname = callnameInput.value.trim();

            if (!callname) {
                showStatus('Please enter a callname', 'error');
                return;
            }

            if (!isConnected) {
                showStatus('Not connected to server', 'error');
                return;
            }

            joinButton.disabled = true;
            joinButton.textContent = 'Joining...';

            // Add timeout for join process
            const joinTimeout = setTimeout(() => {
                joinButton.disabled = false;
                joinButton.textContent = 'Join Game';
                showStatus('Join timeout - please try again', 'error');
            }, 10000); // 10 second timeout

            // Removed excessive debug logging for better performance
            socket.emit('join', {
                callname,
                tankColor: selectedBaseColor,
                tankCamo: selectedCamo,
                teamName: selectedTeam
            });

            // Clear timeout when joined or reconnected
            const clearJoinTimeout = () => {
                clearTimeout(joinTimeout);
                socket.off('joined', clearJoinTimeout);
                socket.off('reconnected', clearJoinTimeout);
            };
            
            socket.once('joined', clearJoinTimeout);
            socket.once('reconnected', clearJoinTimeout);
        });

        // Fire button
        fireButton.addEventListener('click', handleFireButton);
        fireButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireButton();
        }, { passive: false });
        
        // Prevent joystick from interfering with fire button
        fireButton.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });
        
        fireButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        function handleFireButton() {
            
            if (isConnected && playerState && playerState.isAlive) {
                
                // Add glow effect
                fireButton.classList.add('fire-glow');
                
                // Remove glow class after animation completes
                setTimeout(() => {
                    fireButton.classList.remove('fire-glow');
                }, 800);
                
                // Send shoot command and current movement if joystick is active
                let input = { shoot: true };
                
                // Include current movement if joystick is active, but not rotation
                if (joystickActive && (joystickPosition.x !== 0 || joystickPosition.y !== 0)) {
                    const maxDistance = joystickContainer.offsetWidth / 2 - 30;
                    const normalizedX = joystickPosition.x / maxDistance;
                    const normalizedY = joystickPosition.y / maxDistance;
                    input.movement = { x: normalizedX, y: normalizedY };
                }
                
                socket.emit('playerInput', input);
            } else {
            }
        }

        // Touch tracking variables
        let joystickTouchId = null;
        let fireButtonTouchId = null;
        let activeTouches = new Set();

        // Fire button controls
        fireButton.addEventListener('touchstart', handleFireStart, { passive: false });
        fireButton.addEventListener('mousedown', handleFireStart);
        
        function handleFireStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Track touch ID for multitouch
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                fireButtonTouchId = touch.identifier;
                activeTouches.add(touch.identifier);
            }
            
            if (isConnected && playerState && playerState.isAlive) {
                
                // Add glow effect
                fireButton.classList.add('fire-glow');
                
                // Remove glow class after animation completes
                setTimeout(() => {
                    fireButton.classList.remove('fire-glow');
                }, 800);
                
                socket.emit('playerInput', {
                    shoot: true
                });
            }
        }

        // Joystick controls with improved multitouch
        joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
        joystickContainer.addEventListener('mousedown', handleJoystickStart);
        
        function handleJoystickStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Track touch ID for multitouch
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                joystickTouchId = touch.identifier;
                activeTouches.add(touch.identifier);
            }
            
            joystickActive = true;
            const rect = joystickContainer.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            handleJoystickMove(e);
        }

        // Global touch move handler for better responsiveness
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('mousemove', handleJoystickMove);
        
        function handleTouchMove(e) {
            e.preventDefault();
            
            // Handle joystick movement
            if (joystickActive && joystickTouchId !== null) {
                // Find the joystick touch
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (touch.identifier === joystickTouchId) {
                        handleJoystickMoveWithTouch(touch);
                        break;
                    }
                }
            }
        }
        
        function handleJoystickMoveWithTouch(touch) {
            const deltaX = touch.clientX - joystickCenter.x;
            const deltaY = touch.clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = joystickContainer.offsetWidth / 2 - 30;

            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                joystickPosition = {
                    x: Math.cos(angle) * maxDistance,
                    y: Math.sin(angle) * maxDistance
                };
            } else {
                joystickPosition = { x: deltaX, y: deltaY };
            }

            // Update joystick visual position with smooth animation
            joystickStick.style.transform = `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`;

            // Send movement data
            if (isConnected) {
                const normalizedX = joystickPosition.x / maxDistance;
                const normalizedY = joystickPosition.y / maxDistance;
                const rotation = Math.atan2(normalizedY, normalizedX);
                socket.emit('playerInput', {
                    movement: { x: normalizedX, y: normalizedY },
                    rotation: rotation
                });
            }
        }

        function handleJoystickMove(e) {
            if (!joystickActive || (e.touches && e.touches.length > 0)) return;
            e.preventDefault();
            e.stopPropagation();

            const clientX = e.clientX;
            const clientY = e.clientY;

            const deltaX = clientX - joystickCenter.x;
            const deltaY = clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = joystickContainer.offsetWidth / 2 - 30;

            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                joystickPosition = {
                    x: Math.cos(angle) * maxDistance,
                    y: Math.sin(angle) * maxDistance
                };
            } else {
                joystickPosition = { x: deltaX, y: deltaY };
            }

            // Update joystick visual position
            joystickStick.style.transform = `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`;

            // Send movement data
            if (isConnected) {
                const normalizedX = joystickPosition.x / maxDistance;
                const normalizedY = joystickPosition.y / maxDistance;
                const rotation = Math.atan2(normalizedY, normalizedX);
                socket.emit('playerInput', {
                    movement: { x: normalizedX, y: normalizedY },
                    rotation: rotation
                });
            }
        }

        // Global touch end handler
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('mouseup', handleJoystickEnd);
        
        function handleTouchEnd(e) {
            // Check which touch ended
            if (e.changedTouches) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    activeTouches.delete(touch.identifier);
                    
                    if (touch.identifier === joystickTouchId) {
                        handleJoystickEnd(e);
                        joystickTouchId = null;
                    }
                    if (touch.identifier === fireButtonTouchId) {
                        fireButtonTouchId = null;
                    }
                }
            }
        }

        function handleJoystickEnd(e) {
            if (!joystickActive) return;
            e.preventDefault();
            e.stopPropagation();
            
            joystickActive = false;
            joystickPosition = { x: 0, y: 0 };
            joystickStick.style.transform = 'translate(-50%, -50%)';

            if (isConnected) {
                socket.emit('playerInput', {
                    movement: { x: 0, y: 0 }
                });
            }
        }

        // Store balance settings received from server
        let balanceSettings = {
            health: { min: 0, max: 100 },
            speed: { min: 15, max: 50 },
            gasoline: { min: 0, max: 100 },
            rotation: { min: 5, max: 50 },
            ammunition: { min: 0, max: 14 },
            kinetics: { min: 50, max: 300 }
        };

        // Update attributes display
        function updateAttributes(attributes) {
            if (!attributes) return;

            // Helper function to get color based on percentage
            function getColorForPercentage(percent) {
                if (percent >= 80) return { start: '#00ff00', end: '#00cc00', border: '#00ff66', glow: '#00ff00' }; // Green
                if (percent >= 60) return { start: '#8BC34A', end: '#689F38', border: '#9CCC65', glow: '#8BC34A' }; // Light Green
                if (percent >= 40) return { start: '#FFC107', end: '#FF8F00', border: '#FFD54F', glow: '#FFC107' }; // Yellow
                if (percent >= 25) return { start: '#FF9800', end: '#F57C00', border: '#FFB74D', glow: '#FF9800' }; // Orange
                return { start: '#F44336', end: '#D32F2F', border: '#EF5350', glow: '#F44336' }; // Red
            }

            // Health
            const healthPercent = Math.max(0, Math.min(100, ((attributes.health - balanceSettings.health.min) / (balanceSettings.health.max - balanceSettings.health.min)) * 100));
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = `${healthPercent}%`;
            const healthColors = getColorForPercentage(healthPercent);
            healthBar.style.background = `linear-gradient(90deg, ${healthColors.start}, ${healthColors.end})`;
            healthBar.style.borderRight = `2px solid ${healthColors.border}`;
            healthBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${healthColors.glow}`;
            document.getElementById('healthValue').textContent = `${Math.round(healthPercent)}%`;

            // Speed
            const speedPercent = Math.max(0, Math.min(100, ((attributes.speed - balanceSettings.speed.min) / (balanceSettings.speed.max - balanceSettings.speed.min)) * 100));
            const speedBar = document.getElementById('speedBar');
            speedBar.style.width = `${speedPercent}%`;
            const speedColors = getColorForPercentage(speedPercent);
            speedBar.style.background = `linear-gradient(90deg, ${speedColors.start}, ${speedColors.end})`;
            speedBar.style.borderRight = `2px solid ${speedColors.border}`;
            speedBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${speedColors.glow}`;
            document.getElementById('speedValue').textContent = `${Math.round(speedPercent)}%`;

            // Update Gasoline HUD
            const gasFill = document.getElementById('gasFill');
            const gasIcon = document.getElementById('gasIcon');
            const gasolinePercent = Math.max(0, Math.min(100, ((attributes.gasoline - balanceSettings.gasoline.min) / (balanceSettings.gasoline.max - balanceSettings.gasoline.min)) * 100));
            
            // Update fill width
            gasFill.style.width = `${gasolinePercent}%`;
            
            // Update gasoline bar colors based on percentage
            const gasolineColors = getColorForPercentage(gasolinePercent);
            gasFill.style.background = `linear-gradient(90deg, ${gasolineColors.start}, ${gasolineColors.end})`;
            gasFill.style.borderRight = `2px solid ${gasolineColors.border}`;
            gasFill.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${gasolineColors.glow}`;
            
            // Update icon state based on gasoline level
            gasIcon.classList.remove('icon-on', 'icon-flashing');
            
            if (gasolinePercent < 15) {
                // Critical level - flashing
                gasIcon.classList.add('icon-flashing');
            } else if (gasolinePercent < 25) {
                // Low level - solid on
                gasIcon.classList.add('icon-on');
            }

            // Rotation
            const rotationPercent = Math.max(0, Math.min(100, ((attributes.rotation - balanceSettings.rotation.min) / (balanceSettings.rotation.max - balanceSettings.rotation.min)) * 100));
            const rotationBar = document.getElementById('rotationBar');
            rotationBar.style.width = `${rotationPercent}%`;
            const rotationColors = getColorForPercentage(rotationPercent);
            rotationBar.style.background = `linear-gradient(90deg, ${rotationColors.start}, ${rotationColors.end})`;
            rotationBar.style.borderRight = `2px solid ${rotationColors.border}`;
            rotationBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${rotationColors.glow}`;
            document.getElementById('rotationValue').textContent = `${Math.round(rotationPercent)}%`;

            // Kinetics
            const kineticsPercent = Math.max(0, Math.min(100, ((attributes.kinetics - balanceSettings.kinetics.min) / (balanceSettings.kinetics.max - balanceSettings.kinetics.min)) * 100));
            const kineticsBar = document.getElementById('kineticsBar');
            kineticsBar.style.width = `${kineticsPercent}%`;
            const kineticsColors = getColorForPercentage(kineticsPercent);
            kineticsBar.style.background = `linear-gradient(90deg, ${kineticsColors.start}, ${kineticsColors.end})`;
            kineticsBar.style.borderRight = `2px solid ${kineticsColors.border}`;
            kineticsBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${kineticsColors.glow}`;
            document.getElementById('kineticsValue').textContent = `${Math.round(kineticsPercent)}%`;

            // Ammunition (absolute value)
            document.getElementById('ammunitionDisplay').textContent = attributes.ammunition;

            // Update alarm lights
            updateAlarmLights({
                health: healthPercent,
                speed: speedPercent,
                gasoline: gasolinePercent,
                rotation: rotationPercent,
                kinetics: kineticsPercent
            });

            // Update fire button state
            const canFire = playerState.isAlive && attributes.ammunition > 0;
            fireButton.disabled = !canFire;
        }

        // Update alarm lights based on attribute percentages
        function updateAlarmLights(percentages) {
            // Helper function to update alarm state
            function updateAlarmState(alarmElement, percentage) {
                alarmElement.classList.remove('alarm-off', 'alarm-on', 'alarm-flashing', 'alarm-critical');
                
                if (percentage < 5) {
                    // Critical level - fast flashing
                    alarmElement.classList.add('alarm-critical');
                } else if (percentage < 15) {
                    // Low level - flashing
                    alarmElement.classList.add('alarm-flashing');
                } else if (percentage < 25) {
                    // Warning level - solid on
                    alarmElement.classList.add('alarm-on');
                } else {
                    // Normal level - off
                    alarmElement.classList.add('alarm-off');
                }
            }
            
            // Update each alarm light
            updateAlarmState(document.getElementById('healthAlarm'), percentages.health);
            updateAlarmState(document.getElementById('speedAlarm'), percentages.speed);
            updateAlarmState(document.getElementById('rotationAlarm'), percentages.rotation);
            updateAlarmState(document.getElementById('kineticsAlarm'), percentages.kinetics);
        }

        // Show status message
        function showStatus(message, type = 'success') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message show ${type}`;
            setTimeout(() => {
                statusMessage.classList.remove('show');
            }, 3000);
        }

        // Socket event handlers
        socket.on('connect', () => {
            // Removed excessive debug logging for better performance
            isConnected = true;
        });
        
        // Removed excessive socket event debugging for better performance

        socket.on('disconnect', () => {
            isConnected = false;
            showStatus('Disconnected from server', 'error');
            
            // Reset join button on disconnect
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('joined', (data) => {
            // Removed excessive debug logging for better performance
            
            activatePlayState();
            
            // Force a repaint
            playState.offsetHeight;
            
            // Add visual indicator
            document.body.style.backgroundColor = '#2a2a2a';
            
            // Store player data in localStorage
            localStorage.setItem('tankKillerPlayer', JSON.stringify({
                callname: callnameInput.value.trim(),
                tankColor: selectedBaseColor,
                tankCamo: selectedCamo,
                team: selectedTeam
            }));
            
            // Reset join button
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('reconnected', (data) => {
            // Removed excessive debug logging for better performance
            showStatus('Reconnected to the game!');
            activatePlayState();
            
            // Reset join button
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('playerState', (state) => {
            // Removed excessive debug logging for better performance
            playerState = state;
            updateAttributes(state.attributes);
        });

        socket.on('balanceSettings', (settings) => {
            balanceSettings = settings;
        });

        socket.on('damageFeedback', () => {
            document.body.classList.add('damage-feedback');
            setTimeout(() => {
                document.body.classList.remove('damage-feedback');
            }, 300);
        });

        socket.on('settingsApplied', (data) => {
            showStatus(data.message, 'info');
        });

        socket.on('forceReconnect', (data) => {
            
            // Show notification to user
            showStatus(data.message, 'info');
            
            // Reload the page after a short delay to reconnect with new settings
            setTimeout(() => {
                window.location.reload();
            }, 2000);
        });

        // Load saved player data
        window.addEventListener('load', () => {
            // Removed excessive debug logging for better performance
            
            // Initialize selections as fallback
            initializeSelections();
            
            // Always randomize on page refresh, regardless of saved data
            randomizeEverything();
        });

        // Function to handle play state activation
        function activatePlayState() {
            joinState.style.display = 'none';
            playState.classList.add('active');
            document.body.classList.add('play-mode');
        }

        // Function to handle join state activation
        function activateJoinState() {
            playState.classList.remove('active');
            document.body.classList.remove('play-mode');
            joinState.style.display = 'flex';
        }



        // Helper function to determine if a color is light or dark
        function isColorLight(hexColor) {
            // Remove # if present
            const hex = hexColor.replace('#', '');
            
            // Convert hex to RGB
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Return true if light (threshold: 0.4)
            return luminance > 0.4;
        }

        // Color wheel functionality
        function showColorWheel() {
            const overlay = document.createElement('div');
            overlay.className = 'color-wheel-overlay';
            
            const container = document.createElement('div');
            container.className = 'color-wheel-container';
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'color-wheel-close';
            closeBtn.textContent = '';
            closeBtn.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
            
            const wheel = document.createElement('div');
            wheel.className = 'color-wheel';
            
            const indicator = document.createElement('div');
            indicator.className = 'color-wheel-indicator';
            
            wheel.appendChild(indicator);
            container.appendChild(closeBtn);
            container.appendChild(wheel);
            overlay.appendChild(container);
            document.body.appendChild(overlay);
            
            // Handle color wheel interaction
            let isDragging = false;
            
            wheel.addEventListener('mousedown', (e) => {
                isDragging = true;
                updateColorFromWheel(e, wheel, indicator);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    updateColorFromWheel(e, wheel, indicator);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            });
        }
        
        function updateColorFromWheel(e, wheel, indicator) {
            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = e.clientX - centerX;
            const deltaY = e.clientY - centerY;
            
            // Calculate angle and distance
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Limit to wheel radius (100px)
            const maxDistance = 100;
            const clampedDistance = Math.min(distance, maxDistance);
            
            // Calculate saturation and hue
            const saturation = clampedDistance / maxDistance;
            const hue = (angle + 360) % 360;
            
            // Convert to RGB
            const rgb = hslToRgb(hue / 360, saturation, 0.5);
            const hexColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
            
            // Update custom color
            tankColors.custom = hexColor;
            
            // Update the custom color square
            const customSquare = document.querySelector('.base-color-option.custom');
            if (customSquare) {
                customSquare.style.backgroundColor = hexColor;
            }
            
            // Select the custom color
            document.querySelectorAll('.base-color-option').forEach(opt => opt.classList.remove('selected'));
            customSquare.classList.add('selected');
            selectedBaseColor = hexColor;
            
            // Update color name display
            document.getElementById('selectedColorName').textContent = 'Custom';
            
            // Update camo backgrounds
            updateCamoBackgrounds();
            updateTankPreview();
            
            // Update indicator position
            const indicatorX = (clampedDistance / maxDistance) * Math.cos(angle * Math.PI / 180);
            const indicatorY = (clampedDistance / maxDistance) * Math.sin(angle * Math.PI / 180);
            
            indicator.style.left = `calc(50% + ${indicatorX * 100}px)`;
            indicator.style.top = `calc(50% + ${indicatorY * 100}px)`;
        }
        
        // Color conversion utilities
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // Color conversion functions (exact from tank designer)
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [
                Math.round(r * 255),
                Math.round(g * 255),
                Math.round(b * 255)
            ];
        }

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html> 