<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Controller - Tank Killer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: 
                linear-gradient(135deg, 
                    #2a2a2a 0%, 
                    #3a3a3a 25%, 
                    #2a2a2a 50%, 
                    #1a1a1a 75%, 
                    #2a2a2a 100%),
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(0, 0, 0, 0.3) 0%, transparent 50%);
            background-blend-mode: overlay;
            color: #FFFFFF;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s ease;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 255, 255, 0.02) 2px,
                    rgba(255, 255, 255, 0.02) 4px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.03) 2px,
                    rgba(0, 0, 0, 0.03) 4px
                );
            pointer-events: none;
            z-index: 0;
        }

        body.damage-feedback {
            background-color: #b83400;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/green-dust-and-scratches.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.3;
            z-index: -1;
            pointer-events: none;
        }

        /* Join State */
        .join-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .join-form {
            background-color: #1b1b1b;
            padding: 30px;
            border-radius: 15px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            z-index: 10;
        }

        .join-form h2 {
            text-align: center;
            margin-bottom: 30px;
            color: #b83400;
            font-size: 1.8rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #CCCCCC;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background-color: #555555;
            color: #FFFFFF;
            font-size: 16px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #b83400;
        }

        .base-color-options {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .base-color-option {
            width: 100%;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .base-color-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Special metallic gradient for Metal color */
        .base-color-option[data-color="#6a6a6a"] {
            background: radial-gradient(circle at 30% 30%, #8a8a8a, #6a6a6a, #4a4a4a) !important;
        }

        .callname-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .generate-name-btn {
            position: absolute;
            right: 0px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 8px;
            transition: color 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .generate-name-btn.active {
            color: #fff;
        }

        .callname-container input {
            padding-right: 48px;
        }

        .selection-name {
            font-weight: normal;
            opacity: 0.8;
        }

        .base-color-name {
            font-size: 8px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            z-index: 1;
            position: relative;
        }

        .camo-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .camo-option {
            width: 100%;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.8s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .camo-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--base-color);
            background-image: var(--texture-url);
            background-repeat: repeat;
            background-size: calc(100px * var(--texture-scale));
            opacity: var(--texture-opacity);
            background-blend-mode: var(--texture-blend-mode);
            border-radius: 8px;
            pointer-events: none;
            transition: background-color 0.8s ease;
        }

        .camo-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .camo-name {
            font-size: 8px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            z-index: 1;
            position: relative;
        }

        .team-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .team-option {
            width: 100%;
            height: 40px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border-color 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .team-option.selected {
            border-color: #FFFFFF;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .team-badge {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            object-fit: contain;
        }

        .join-button {
            width: 100%;
            padding: 15px;
            background-color: #b83400;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .join-button:hover {
            background-color: #a03000;
        }

        .join-button:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }

        /* Play State */
        .play-state {
            flex: 1;
            display: none;
            flex-direction: column;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10;
            overflow-y: auto;
            padding: 5px;
            box-sizing: border-box;
        }

        .play-state.active {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Attribute Banner */
        .attribute-banner {
            background-color: #1b1b1b;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            border: 3px solid #111;
            border-radius: 0px;
            box-shadow: inset 0 0 10px #000, 0 4px 10px rgba(0, 0, 0, 0.7), 0 -2px 6px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .attribute-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/brushed-alum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.1;
            z-index: 0;
            pointer-events: none;
        }

        .attribute-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 60px;
            max-width: 80px;
        }

        .attribute-label {
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            margin-bottom: 5px;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attribute-bar {
            width: 100%;
            height: 22px;
            background: #111;
            border: 2px solid #444;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 6px #000;
            display: flex;
            align-items: flex-start;
        }

        .attribute-fill {
            height: 80%;
            margin-top: 2px;
            background: linear-gradient(90deg, #ffe066, #ffcc33);
            border-right: 2px solid #f5e087;
            box-shadow: inset 0 0 4px #000, 0 0 6px #ffcc33;
            transition: width 0.3s ease;
        }

        .attribute-fill.health { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.speed { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.rotation { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }
        .attribute-fill.kinetics { 
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-right: 2px solid #00ff66;
            box-shadow: inset 0 0 4px #000, 0 0 6px #00ff00;
        }

        .attribute-value {
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffcc33;
            background: linear-gradient(to bottom, #1c1c1c, #0a0a0a);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #444;
            text-shadow: 
                0 0 2px #ffcc33,
                0 0 4px #ffcc33;
            text-align: center;
            width: 50px;
            min-width: 50px;
            max-width: 50px;
            margin-top: 3px;
        }

        /* Alarm Lights */
        .alarm-light {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid;
            display: inline-block;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* Alarm ON */
        .alarm-on {
            background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            border-color: #660000;
            box-shadow:
                0 0 8px 2px #ff1a1a,
                inset 0 0 3px #ff6666,
                0 0 12px 3px rgba(255, 0, 0, 0.5);
            animation: blink 1s infinite alternate;
        }

        /* Alarm OFF */
        .alarm-off {
            background: radial-gradient(circle at 30% 30%, #666, #333);
            border-color: #555;
            box-shadow:
                inset 0 0 2px #222,
                0 0 1px #000;
        }

        /* Blinking Animation */
        @keyframes blink {
            0% {
                box-shadow:
                    0 0 4px 1px #ff1a1a,
                    inset 0 0 2px #ff3333,
                    0 0 8px 2px rgba(255, 0, 0, 0.3);
                background: radial-gradient(circle at 30% 30%, #cc0000, #660000);
            }
            100% {
                box-shadow:
                    0 0 12px 3px #ff1a1a,
                    inset 0 0 4px #ff9999,
                    0 0 16px 4px rgba(255, 0, 0, 0.7);
                background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            }
        }

        /* Fast Blinking Animation for Critical Levels */
        @keyframes blinkCritical {
            0% {
                box-shadow:
                    0 0 4px 1px #ff1a1a,
                    inset 0 0 2px #ff3333,
                    0 0 8px 2px rgba(255, 0, 0, 0.3);
                background: radial-gradient(circle at 30% 30%, #cc0000, #660000);
            }
            100% {
                box-shadow:
                    0 0 12px 3px #ff1a1a,
                    inset 0 0 4px #ff9999,
                    0 0 16px 4px rgba(255, 0, 0, 0.7);
                background: radial-gradient(circle at 30% 30%, #ff4d4d, #990000);
            }
        }

        /* Alarm Flashing Animation */
        .alarm-flashing {
            animation: blink 1s infinite alternate;
        }

        /* Critical Alarm Flashing Animation - Faster */
        .alarm-critical {
            animation: blinkCritical 0.3s infinite alternate;
        }

        /* Game Controls */
        .game-controls {
            padding: 20px;
            text-align: center;
        }

        /* Fire Button */
        .fire-button-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-left: 50px;
        }

        .fire-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4a0000, #1a0000);
            border: 3px solid #110000;
            color: #e6d0d0;
            font-size: 26px;
            font-family: 'Black Ops One', monospace;
            font-weight: normal;
            cursor: pointer;
            box-shadow:
                inset 1px 1px 2px #300000,
                inset -1px -1px 3px #000,
                0 2px 4px rgba(0, 0, 0, 0.6);
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #000,
                0 0 2px #600;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 1px;
            position: relative;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            background-blend-mode: multiply;
            filter: contrast(120%) brightness(90%);
        }



        .fire-button:active {
            transform: translateY(1px);
        }

        .fire-button.fire-glow {
            background: radial-gradient(circle at 30% 30%, #8b0000, #660000);
            box-shadow:
                inset 2px 2px 3px #000,
                0 1px 2px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(139, 0, 0, 0.6),
                0 0 30px rgba(139, 0, 0, 0.3);
            animation: fireGlow 0.8s ease-out;
        }

        @keyframes fireGlow {
            0% {
                background: radial-gradient(circle at 30% 30%, #8b0000, #660000);
                box-shadow:
                    inset 2px 2px 3px #000,
                    0 1px 2px rgba(0, 0, 0, 0.3),
                    0 0 15px rgba(139, 0, 0, 0.6),
                    0 0 30px rgba(139, 0, 0, 0.3);
            }
            50% {
                background: radial-gradient(circle at 30% 30%, #730000, #520000);
                box-shadow:
                    inset 2px 2px 3px #000,
                    0 1px 2px rgba(0, 0, 0, 0.3),
                    0 0 12px rgba(139, 0, 0, 0.4),
                    0 0 25px rgba(139, 0, 0, 0.2);
            }
            100% {
                background: radial-gradient(circle at 30% 30%, #4a0000, #1a0000);
                box-shadow:
                    inset 1px 1px 2px #300000,
                    inset -1px -1px 3px #000,
                    0 2px 4px rgba(0, 0, 0, 0.6);
            }
        }

        .fire-button:disabled {
            background: linear-gradient(to bottom, #666666 0%, #444444 100%);
            border-color: #333333;
            color: #999999;
            cursor: not-allowed;
            box-shadow:
                0 6px #333333,
                inset 0 0 6px #555555;
        }

        /* Wear overlay */
        .fire-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: 
                radial-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(135deg, rgba(255, 255, 255, 0.025) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.025) 50%, rgba(255, 255, 255, 0.025) 75%, transparent 75%, transparent);
            background-size: 4px 4px, 8px 8px;
            opacity: 0.3;
            z-index: 2;
        }

        /* 60-lines texture overlay */
        .fire-button::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/60-lines.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 1;
            z-index: 1;
            pointer-events: none;
            border-radius: 50%;
        }

        .ammo-label {
            font-size: 0.9rem;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow:
                0 1px 0 #111,
                0 -1px 1px #666,
                0 0 1px #000;
            text-align: center;
        }

        .fire-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .ammo-label {
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            margin-bottom: 1px;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .ammunition-display {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            font-weight: bold;
            color: #ffcc33;
            background: linear-gradient(to bottom, #1c1c1c, #0a0a0a);
            padding: 4px 14px;
            border-radius: 8px;
            border: 1px solid #444;
            text-shadow: 
                0 0 3px #ffcc33,
                0 0 6px #ffcc33;
            text-align: center;
            width: 60px;
            min-width: 60px;
            max-width: 60px;
            z-index: 1;
        }

        /* Joystick */
        .joystick-container {
            position: relative;
            width: 200px;
            height: 200px;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            margin: 0 auto;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #3a3a3a;
            border: 3px solid #666;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: inset 0 0 12px #1a1a1a;
        }

        .joystick-base::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/light-aluminum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.2;
            z-index: 0;
            pointer-events: none;
            border-radius: 50%;
        }

        .joystick-center {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #111;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .joystick-stick {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #462e2e, #000000);
            box-shadow:
                inset -3px -3px 6px rgba(255, 255, 255, 0.1),
                inset 3px 3px 6px rgba(0, 0, 0, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            cursor: pointer;
            transition: transform 0.05s ease-out;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .joystick-stick::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/dark-leather.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 1;
            z-index: 0;
            pointer-events: none;
            border-radius: 50%;
        }

        /* Status Messages */
        .status-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1b1b1b;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        }

        /* Gasoline HUD */
        #gasolineHUD {
            position: relative;
            width: 280px;
            height: 70px;
            background: #2a2a2a;
            border: 3px solid #111;
            border-radius: 10px;
            box-shadow:
                inset 0 0 10px #000,
                0 4px 10px rgba(0,0,0,0.7),
                0 -2px 6px rgba(255,255,255,0.1);
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            z-index: 1000;
            margin: 0 auto 20px auto;
        }

        #gasolineHUD::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('/assets/images/textures/brushed-alum.png');
            background-repeat: repeat;
            background-size: auto;
            opacity: 0.2;
            z-index: -1;
            pointer-events: none;
        }

        .gasoline-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 38px;
            color: rgba(156, 29, 29, 0.08);
            transition: color 0.3s ease, filter 0.3s ease;
            z-index: 1;
            text-shadow:
                0 1px 1px #161010,
                0 -1px 1px #181212,
                -1px 0 1px #929292,
                1px 0 1px #c0c0c0,
                0 0 5px rgba(58, 47, 47, 0.2);
            filter: none;
        }

        .icon-on {
            color: #9c1d1d;
            filter: drop-shadow(0 0 4px rgba(156, 29, 29, 0.3)) drop-shadow(0 0 10px rgba(156, 29, 29, 0.2));
        }

        .icon-flashing {
            animation: flash 1s infinite alternate;
        }

        @keyframes flash {
            from {
                color: rgba(156, 29, 29, 0.3);
                filter: drop-shadow(0 0 4px rgba(156, 29, 29, 0.2));
            }
            to {
                color: #9c1d1d;
                filter: drop-shadow(0 0 6px rgba(156, 29, 29, 0.6)) drop-shadow(0 0 12px rgba(156, 29, 29, 0.8));
            }
        }

        .gasoline-bar {
            position: absolute;
            top: 40%;
            left: 64px;
            transform: translateY(-50%);
            width: 190px;
            height: 22px;
            background: #111;
            border: 2px solid #444;
            border-radius: 4px;
            box-shadow: inset 0 0 6px #000;
            display: flex;
            align-items: flex-start;
            z-index: 2;
        }

        .gasoline-fill {
            height: 80%;
            margin-top: 2px;
            background: linear-gradient(90deg, #ffe066, #ffcc33);
            border-right: 2px solid #f5e087;
            box-shadow: inset 0 0 4px #000, 0 0 6px #ffcc33;
            transition: width 0.3s ease;
        }

        .gasoline-label {
            position: absolute;
            bottom: 10px;
            right: 20px;
            font-size: 13px;
            letter-spacing: 1px;
            color: #706363;
            text-shadow:
                1px 1px 0 #000,
                -1px -1px 0 #444,
                0 1px 1px #000,
                0 -1px 1px #444,
                1px -1px 0 #222,
                -1px 1px 0 #222;
            z-index: 2;
        }

        .status-message.show {
            display: block;
        }

        /* Bolt styling */
        .bolt {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #888, #2a2a2a);
            box-shadow:
                inset -1px -1px 2px rgba(255, 255, 255, 0.1),
                inset 1px 1px 3px rgba(0, 0, 0, 0.6),
                0 0 2px rgba(0, 0, 0, 0.4);
            position: absolute;
            border: 1px solid #3c3a3a;
            filter: contrast(110%) brightness(90%);
        }

        .bolt::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        .bolt::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(-45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        /* Attribute banner bolts - darker metallic */
        .attribute-bolt {
            background: radial-gradient(circle at 30% 30%, #444, #111);
            border: 1px solid #1a1a1a;
            filter: contrast(120%) brightness(70%);
        }

        .attribute-bolt::before, .attribute-bolt::after {
            background: linear-gradient(to right, #111, #333, #111);
            box-shadow: 
                inset 0.5px 0 0.5px #555,
                inset -0.5px 0 0.5px #111;
        }

        /* Background bolts */
        .background-bolt {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #888, #2a2a2a);
            box-shadow:
                inset -1px -1px 2px rgba(255, 255, 255, 0.1),
                inset 1px 1px 3px rgba(0, 0, 0, 0.6),
                0 0 2px rgba(0, 0, 0, 0.4);
            position: absolute;
            border: 1px solid #3c3a3a;
            filter: contrast(110%) brightness(90%);
            z-index: 1;
        }

        .background-bolt::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        .background-bolt::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 1px;
            background: linear-gradient(to right, #111, #888, #111);
            transform: translate(-50%, -50%) rotate(-45deg);
            border-radius: 0.5px;
            box-shadow: 
                inset 0.5px 0 0.5px #aaa,
                inset -0.5px 0 0.5px #555;
        }

        .status-message.success {
            background-color: #4CAF50;
        }

        .status-message.error {
            background-color: #F44336;
        }

        @media (max-width: 480px) {
            .join-form {
                padding: 20px;
                margin: 10px;
            }

            .fire-button {
                width: 100px;
                height: 100px;
                font-size: 20px;
            }

            .joystick-container {
                width: 150px;
                height: 150px;
            }

            .joystick-stick {
                width: 50px;
                height: 50px;
            }

            .attribute-banner {
                padding: 10px;
            }

            .attribute-item {
                min-width: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="background-bolt" style="top: 110px; left: 20px;"></div>
        <div class="background-bolt" style="top: 110px; right: 20px;"></div>
        <div class="background-bolt" style="bottom: 20px; left: 20px;"></div>
        <div class="background-bolt" style="bottom: 20px; right: 20px;"></div>
        <!-- Join State -->
        <div class="join-state" id="joinState" style="display: flex;">
            <div class="join-form">

                
                <div class="form-group">
                    <label for="callname">Callname</label>
                    <div class="callname-container">
                        <input type="text" id="callname" placeholder="Enter your callname" maxlength="15">
                        <button type="button" id="generateName" class="generate-name-btn" title="Generate random name">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label>Tank colour: <span id="selectedColorName" class="selection-name">Forest</span></label>
                    <div class="base-color-options" id="baseColorOptions">
                        <!-- Base color options will be dynamically generated -->
                    </div>
                </div>

                <div class="form-group">
                    <label>Camo: <span id="selectedCamoName" class="selection-name">Dazzle</span></label>
                    <div class="camo-options" id="camoOptions">
                        <!-- Camo options will be dynamically generated -->
                    </div>
                </div>

                <div class="form-group">
                    <label>Team:</label>
                    <div class="team-options">
                        <div class="team-option selected" data-team="NATO" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-nato.png" alt="NATO" class="team-badge">
                            <span>NATO</span>
                        </div>
                        <div class="team-option" data-team="CSTO" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-csto.png" alt="CSTO" class="team-badge">
                            <span>CSTO</span>
                        </div>
                        <div class="team-option" data-team="PLA" style="background-color: #302f2f;">
                            <img src="/assets/images/teams/badges/team-pla.png" alt="PLA" class="team-badge">
                            <span>PLA</span>
                        </div>
                    </div>
                </div>
                </div>

                <button class="join-button" id="joinButton">Join Game</button>
                <button type="button" onclick="testStateTransition()" style="margin-top: 10px; padding: 10px; background: #666;">Test State Transition</button>
            </div>
        </div>

        <!-- Play State -->
        <div class="play-state" id="playState">
            <!-- Attribute Banner -->
            <div class="attribute-banner">
                <div class="bolt attribute-bolt" style="top: 1px; left: 1px;"></div>
                <div class="bolt attribute-bolt" style="top: 1px; right: 1px;"></div>
                <div class="bolt attribute-bolt" style="bottom: 1px; left: 1px;"></div>
                <div class="bolt attribute-bolt" style="bottom: 1px; right: 1px;"></div>
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="healthAlarm"></span>
                        HEALTH
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill health" id="healthBar"></div>
                    </div>
                    <div class="attribute-value" id="healthValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="speedAlarm"></span>
                        SPEED
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill speed" id="speedBar"></div>
                    </div>
                    <div class="attribute-value" id="speedValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="rotationAlarm"></span>
                        ROTATION
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill rotation" id="rotationBar"></div>
                    </div>
                    <div class="attribute-value" id="rotationValue">100%</div>
                </div>
                
                <div class="attribute-item">
                    <div class="attribute-label">
                        <span class="alarm-light alarm-off" id="kineticsAlarm"></span>
                        KINETICS
                    </div>
                    <div class="attribute-bar">
                        <div class="attribute-fill kinetics" id="kineticsBar"></div>
                    </div>
                    <div class="attribute-value" id="kineticsValue">100%</div>
                </div>
            </div>

            <!-- Gasoline HUD -->
            <div id="gasolineHUD" class="gasoline-container">
                <div class="bolt" style="top: 5px; left: 5px;"></div>
                <div class="bolt" style="top: 5px; right: 5px;"></div>
                <div class="bolt" style="bottom: 5px; left: 5px;"></div>
                <div class="bolt" style="bottom: 5px; right: 5px;"></div>
                <span class="material-icons gasoline-icon" id="gasIcon">local_gas_station</span>
                <div class="gasoline-bar">
                    <div class="gasoline-fill" id="gasFill"></div>
                </div>
                <div class="gasoline-label">GASOLINE</div>
            </div>

            <!-- Game Controls -->
            <div class="game-controls">
                <!-- Fire Controls -->
                <div class="fire-controls">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="ammo-label">AMMO</div>
                        <div class="ammunition-display" id="ammunitionDisplay">14</div>
                    </div>
                    <button class="fire-button" id="fireButton">
                        FIRE
                    </button>
                </div>

                <!-- Joystick -->
                <div class="joystick-container" id="joystickContainer">
                    <div class="joystick-base">
                        <div class="joystick-center"></div>
                        <div class="joystick-stick" id="joystickStick"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Message -->
    <div class="status-message" id="statusMessage"></div>

    <!-- Shared Tank Colors Configuration -->
    <script src="/src/shared/tankColors.js"></script>
    <script src="/src/shared/tankCamo.js"></script>
    <script src="/src/shared/defaultNames.js"></script>

    <script>
        // Debug: Check if external scripts loaded
        console.log('Controller script starting...');
        console.log('tankColors available:', typeof tankColors !== 'undefined');
        console.log('tankCamos available:', typeof tankCamos !== 'undefined');
        console.log('defaultNames available:', typeof defaultNames !== 'undefined');
        console.log('ranks available:', typeof ranks !== 'undefined');
        
        // Game state
        let playerState = null;
        let isConnected = false;
        let selectedColor = '#1f2e23';
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickPosition = { x: 0, y: 0 };
        let inputInterval = null;

        // DOM elements
        const joinState = document.getElementById('joinState');
        const playState = document.getElementById('playState');
        const callnameInput = document.getElementById('callname');
        const joinButton = document.getElementById('joinButton');
        const fireButton = document.getElementById('fireButton');
        const ammunitionDisplay = document.getElementById('ammunitionDisplay');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');
        const statusMessage = document.getElementById('statusMessage');
        
        // Debug DOM elements
        console.log('DOM elements found:');
        console.log('joinState:', joinState);
        console.log('playState:', playState);
        console.log('callnameInput:', callnameInput);
        console.log('joinButton:', joinButton);
        console.log('fireButton:', fireButton);

        // Socket connection
        const socket = io();

        // Game state variables
        let selectedBaseColor = '#1f2e23';
        let selectedCamo = 'dazzle';
        let selectedTeam = 'NATO';

        // Generate random name functionality
        const generateNameBtn = document.getElementById('generateName');
        
        function generateRandomName() {
            const randomRank = ranks[Math.floor(Math.random() * ranks.length)];
            const teamNames = defaultNames[selectedTeam] || defaultNames.NATO;
            const randomName = teamNames[Math.floor(Math.random() * teamNames.length)];
            return `${randomRank} ${randomName}`;
        }

        generateNameBtn.addEventListener('click', () => {
            const randomName = generateRandomName();
            callnameInput.value = randomName;
            
            // Add active state
            generateNameBtn.classList.add('active');
            
            // Remove active state after 200ms
            setTimeout(() => {
                generateNameBtn.classList.remove('active');
            }, 200);
        });

        // Initialize UI elements
        function initializeUI() {
            // Generate base color options
            const baseColorContainer = document.getElementById('baseColorOptions');
            
            // Check if tankColors is available
            if (typeof tankColors === 'undefined') {
                console.error('tankColors is not defined! Check if tankColors.js is loading correctly.');
                return;
            }
            
            console.log('Generating base color options...');
            console.log('tankColors object:', tankColors);
            
            Object.entries(tankColors).forEach(([key, color]) => {
                const colorOption = document.createElement('div');
                colorOption.className = 'base-color-option';
                colorOption.style.backgroundColor = color.hex;
                colorOption.dataset.color = color.hex;
                colorOption.dataset.name = color.label;
                
                // Add click event
                colorOption.addEventListener('click', () => {
                    document.querySelectorAll('.base-color-option').forEach(opt => opt.classList.remove('selected'));
                    colorOption.classList.add('selected');
                    selectedBaseColor = color.hex;
                    
                    // Update color name display
                    document.getElementById('selectedColorName').textContent = color.label;
                    
                    updateCamoBackgrounds();
                });
                
                baseColorContainer.appendChild(colorOption);
            });

            // Generate camo options
            const camoContainer = document.getElementById('camoOptions');
            
            // Check if tankCamos is available
            if (typeof tankCamos === 'undefined') {
                console.error('tankCamos is not defined! Check if tankCamo.js is loading correctly.');
                return;
            }
            
            console.log('Generating camo options...');
            console.log('tankCamos object:', tankCamos);
            
            Object.entries(tankCamos).forEach(([key, config]) => {
                const camoOption = document.createElement('div');
                camoOption.className = 'camo-option';
                camoOption.dataset.camo = key;
                camoOption.dataset.name = config.name;
                camoOption.dataset.texture = config.texture;
                camoOption.dataset.opacity = config.opacity;
                camoOption.dataset.scale = config.scale;
                
                // Set CSS variables for texture
                camoOption.style.setProperty('--texture-url', `url('/assets/images/${config.texture}')`);
                camoOption.style.setProperty('--texture-opacity', config.opacity);
                camoOption.style.setProperty('--texture-scale', config.scale);
                camoOption.style.setProperty('--texture-blend-mode', config.blendMode || 'normal');
                camoOption.style.setProperty('--texture-overrides', JSON.stringify(config.overrides || {}));
                
                // Add click event
                camoOption.addEventListener('click', () => {
                    document.querySelectorAll('.camo-option').forEach(opt => opt.classList.remove('selected'));
                    camoOption.classList.add('selected');
                    selectedCamo = key;
                    
                    // Update camo name display
                    document.getElementById('selectedCamoName').textContent = config.name;
                });
                
                camoContainer.appendChild(camoOption);
            });
        }
        
        // Call initialization
        initializeUI();

        // Function to update camo option backgrounds based on selected base color
        function updateCamoBackgrounds() {
            const camoOptions = document.querySelectorAll('.camo-option');
            
            // Add a slight stagger effect for smoother animation
            camoOptions.forEach((option, index) => {
                setTimeout(() => {
                    option.style.backgroundColor = selectedBaseColor;
                    option.style.setProperty('--base-color', selectedBaseColor);
                    
                    // Check for blend mode overrides
                    const overrides = JSON.parse(option.style.getPropertyValue('--texture-overrides') || '{}');
                    const colorKey = getColorKeyFromHex(selectedBaseColor);
                    if (colorKey && overrides[colorKey]) {
                        option.style.setProperty('--texture-blend-mode', overrides[colorKey].blendMode);
                    } else {
                        // Reset to default blend mode from the camo config
                        const camoKey = option.dataset.camo;
                        const camoConfig = tankCamos[camoKey];
                        const defaultBlendMode = camoConfig ? camoConfig.blendMode || 'normal' : 'normal';
                        option.style.setProperty('--texture-blend-mode', defaultBlendMode);
                    }
                }, index * 80); // 80ms delay between each option
            });
        }

        // Initialize camo backgrounds and set initial base color variable
        updateCamoBackgrounds();
        document.querySelectorAll('.camo-option').forEach(option => {
            option.style.setProperty('--base-color', selectedBaseColor);
        });

        // Team selection
        document.querySelectorAll('.team-option').forEach(option => {
            option.addEventListener('click', () => {
                console.log('Team option clicked:', option.dataset.team);
                document.querySelectorAll('.team-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedTeam = option.dataset.team;
                console.log('Selected team:', selectedTeam);
            });
        });

        // Initialize selections (will be overridden by load logic)
        function initializeSelections() {
            // Select first color, camo, and team by default (fallback)
            const firstColor = document.querySelector('.base-color-option');
            const firstCamo = document.querySelector('.camo-option');
            const firstTeam = document.querySelector('.team-option');
            
            if (firstColor) firstColor.classList.add('selected');
            if (firstCamo) firstCamo.classList.add('selected');
            if (firstTeam) firstTeam.classList.add('selected');
        }

        // Join game
        joinButton.addEventListener('click', () => {
            console.log('Join button clicked');
            const callname = callnameInput.value.trim();
            console.log('Callname:', callname);
            console.log('Selected team:', selectedTeam);
            console.log('Selected color:', selectedBaseColor);
            console.log('Selected camo:', selectedCamo);

            if (!callname) {
                showStatus('Please enter a callname', 'error');
                return;
            }

            if (!isConnected) {
                showStatus('Not connected to server', 'error');
                return;
            }

            joinButton.disabled = true;
            joinButton.textContent = 'Joining...';

            // Add timeout for join process
            const joinTimeout = setTimeout(() => {
                joinButton.disabled = false;
                joinButton.textContent = 'Join Game';
                showStatus('Join timeout - please try again', 'error');
            }, 10000); // 10 second timeout

            console.log('Sending join event to server...');
            socket.emit('join', {
                callname,
                tankColor: selectedBaseColor,
                tankCamo: selectedCamo,
                teamName: selectedTeam
            });
            console.log('Join event sent to server');

            // Clear timeout when joined or reconnected
            const clearJoinTimeout = () => {
                clearTimeout(joinTimeout);
                socket.off('joined', clearJoinTimeout);
                socket.off('reconnected', clearJoinTimeout);
            };
            
            socket.once('joined', clearJoinTimeout);
            socket.once('reconnected', clearJoinTimeout);
        });

        // Fire button
        fireButton.addEventListener('click', handleFireButton);
        fireButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            handleFireButton();
        }, { passive: false });
        
        // Prevent joystick from interfering with fire button
        fireButton.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });
        
        fireButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
        }, { passive: false });

        function handleFireButton() {
            
            if (isConnected && playerState && playerState.isAlive) {
                
                // Add glow effect
                fireButton.classList.add('fire-glow');
                
                // Remove glow class after animation completes
                setTimeout(() => {
                    fireButton.classList.remove('fire-glow');
                }, 800);
                
                // Send shoot command and current movement if joystick is active
                let input = { shoot: true };
                
                // Include current movement if joystick is active, but not rotation
                if (joystickActive && (joystickPosition.x !== 0 || joystickPosition.y !== 0)) {
                    const maxDistance = joystickContainer.offsetWidth / 2 - 30;
                    const normalizedX = joystickPosition.x / maxDistance;
                    const normalizedY = joystickPosition.y / maxDistance;
                    input.movement = { x: normalizedX, y: normalizedY };
                }
                
                socket.emit('playerInput', input);
            } else {
            }
        }

        // Touch tracking variables
        let joystickTouchId = null;
        let fireButtonTouchId = null;
        let activeTouches = new Set();

        // Fire button controls
        fireButton.addEventListener('touchstart', handleFireStart, { passive: false });
        fireButton.addEventListener('mousedown', handleFireStart);
        
        function handleFireStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Track touch ID for multitouch
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                fireButtonTouchId = touch.identifier;
                activeTouches.add(touch.identifier);
            }
            
            if (isConnected && playerState && playerState.isAlive) {
                
                // Add glow effect
                fireButton.classList.add('fire-glow');
                
                // Remove glow class after animation completes
                setTimeout(() => {
                    fireButton.classList.remove('fire-glow');
                }, 800);
                
                socket.emit('playerInput', {
                    shoot: true
                });
            }
        }

        // Joystick controls with improved multitouch
        joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
        joystickContainer.addEventListener('mousedown', handleJoystickStart);
        
        function handleJoystickStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Track touch ID for multitouch
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                joystickTouchId = touch.identifier;
                activeTouches.add(touch.identifier);
            }
            
            joystickActive = true;
            const rect = joystickContainer.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            handleJoystickMove(e);
        }

        // Global touch move handler for better responsiveness
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('mousemove', handleJoystickMove);
        
        function handleTouchMove(e) {
            e.preventDefault();
            
            // Handle joystick movement
            if (joystickActive && joystickTouchId !== null) {
                // Find the joystick touch
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    if (touch.identifier === joystickTouchId) {
                        handleJoystickMoveWithTouch(touch);
                        break;
                    }
                }
            }
        }
        
        function handleJoystickMoveWithTouch(touch) {
            const deltaX = touch.clientX - joystickCenter.x;
            const deltaY = touch.clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = joystickContainer.offsetWidth / 2 - 30;

            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                joystickPosition = {
                    x: Math.cos(angle) * maxDistance,
                    y: Math.sin(angle) * maxDistance
                };
            } else {
                joystickPosition = { x: deltaX, y: deltaY };
            }

            // Update joystick visual position with smooth animation
            joystickStick.style.transform = `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`;

            // Send movement data
            if (isConnected) {
                const normalizedX = joystickPosition.x / maxDistance;
                const normalizedY = joystickPosition.y / maxDistance;
                const rotation = Math.atan2(normalizedY, normalizedX);
                socket.emit('playerInput', {
                    movement: { x: normalizedX, y: normalizedY },
                    rotation: rotation
                });
            }
        }

        function handleJoystickMove(e) {
            if (!joystickActive || (e.touches && e.touches.length > 0)) return;
            e.preventDefault();
            e.stopPropagation();

            const clientX = e.clientX;
            const clientY = e.clientY;

            const deltaX = clientX - joystickCenter.x;
            const deltaY = clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = joystickContainer.offsetWidth / 2 - 30;

            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                joystickPosition = {
                    x: Math.cos(angle) * maxDistance,
                    y: Math.sin(angle) * maxDistance
                };
            } else {
                joystickPosition = { x: deltaX, y: deltaY };
            }

            // Update joystick visual position
            joystickStick.style.transform = `translate(calc(-50% + ${joystickPosition.x}px), calc(-50% + ${joystickPosition.y}px))`;

            // Send movement data
            if (isConnected) {
                const normalizedX = joystickPosition.x / maxDistance;
                const normalizedY = joystickPosition.y / maxDistance;
                const rotation = Math.atan2(normalizedY, normalizedX);
                socket.emit('playerInput', {
                    movement: { x: normalizedX, y: normalizedY },
                    rotation: rotation
                });
            }
        }

        // Global touch end handler
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('mouseup', handleJoystickEnd);
        
        function handleTouchEnd(e) {
            // Check which touch ended
            if (e.changedTouches) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    activeTouches.delete(touch.identifier);
                    
                    if (touch.identifier === joystickTouchId) {
                        handleJoystickEnd(e);
                        joystickTouchId = null;
                    }
                    if (touch.identifier === fireButtonTouchId) {
                        fireButtonTouchId = null;
                    }
                }
            }
        }

        function handleJoystickEnd(e) {
            if (!joystickActive) return;
            e.preventDefault();
            e.stopPropagation();
            
            joystickActive = false;
            joystickPosition = { x: 0, y: 0 };
            joystickStick.style.transform = 'translate(-50%, -50%)';

            if (isConnected) {
                socket.emit('playerInput', {
                    movement: { x: 0, y: 0 }
                });
            }
        }

        // Store balance settings received from server
        let balanceSettings = {
            health: { min: 0, max: 100 },
            speed: { min: 15, max: 50 },
            gasoline: { min: 0, max: 100 },
            rotation: { min: 5, max: 50 },
            ammunition: { min: 0, max: 14 },
            kinetics: { min: 50, max: 300 }
        };

        // Update attributes display
        function updateAttributes(attributes) {
            if (!attributes) return;

            // Helper function to get color based on percentage
            function getColorForPercentage(percent) {
                if (percent >= 80) return { start: '#00ff00', end: '#00cc00', border: '#00ff66', glow: '#00ff00' }; // Green
                if (percent >= 60) return { start: '#8BC34A', end: '#689F38', border: '#9CCC65', glow: '#8BC34A' }; // Light Green
                if (percent >= 40) return { start: '#FFC107', end: '#FF8F00', border: '#FFD54F', glow: '#FFC107' }; // Yellow
                if (percent >= 25) return { start: '#FF9800', end: '#F57C00', border: '#FFB74D', glow: '#FF9800' }; // Orange
                return { start: '#F44336', end: '#D32F2F', border: '#EF5350', glow: '#F44336' }; // Red
            }

            // Health
            const healthPercent = Math.max(0, Math.min(100, ((attributes.health - balanceSettings.health.min) / (balanceSettings.health.max - balanceSettings.health.min)) * 100));
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = `${healthPercent}%`;
            const healthColors = getColorForPercentage(healthPercent);
            healthBar.style.background = `linear-gradient(90deg, ${healthColors.start}, ${healthColors.end})`;
            healthBar.style.borderRight = `2px solid ${healthColors.border}`;
            healthBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${healthColors.glow}`;
            document.getElementById('healthValue').textContent = `${Math.round(healthPercent)}%`;

            // Speed
            const speedPercent = Math.max(0, Math.min(100, ((attributes.speed - balanceSettings.speed.min) / (balanceSettings.speed.max - balanceSettings.speed.min)) * 100));
            const speedBar = document.getElementById('speedBar');
            speedBar.style.width = `${speedPercent}%`;
            const speedColors = getColorForPercentage(speedPercent);
            speedBar.style.background = `linear-gradient(90deg, ${speedColors.start}, ${speedColors.end})`;
            speedBar.style.borderRight = `2px solid ${speedColors.border}`;
            speedBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${speedColors.glow}`;
            document.getElementById('speedValue').textContent = `${Math.round(speedPercent)}%`;

            // Update Gasoline HUD
            const gasFill = document.getElementById('gasFill');
            const gasIcon = document.getElementById('gasIcon');
            const gasolinePercent = Math.max(0, Math.min(100, ((attributes.gasoline - balanceSettings.gasoline.min) / (balanceSettings.gasoline.max - balanceSettings.gasoline.min)) * 100));
            
            // Update fill width
            gasFill.style.width = `${gasolinePercent}%`;
            
            // Update gasoline bar colors based on percentage
            const gasolineColors = getColorForPercentage(gasolinePercent);
            gasFill.style.background = `linear-gradient(90deg, ${gasolineColors.start}, ${gasolineColors.end})`;
            gasFill.style.borderRight = `2px solid ${gasolineColors.border}`;
            gasFill.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${gasolineColors.glow}`;
            
            // Update icon state based on gasoline level
            gasIcon.classList.remove('icon-on', 'icon-flashing');
            
            if (gasolinePercent < 15) {
                // Critical level - flashing
                gasIcon.classList.add('icon-flashing');
            } else if (gasolinePercent < 25) {
                // Low level - solid on
                gasIcon.classList.add('icon-on');
            }

            // Rotation
            const rotationPercent = Math.max(0, Math.min(100, ((attributes.rotation - balanceSettings.rotation.min) / (balanceSettings.rotation.max - balanceSettings.rotation.min)) * 100));
            const rotationBar = document.getElementById('rotationBar');
            rotationBar.style.width = `${rotationPercent}%`;
            const rotationColors = getColorForPercentage(rotationPercent);
            rotationBar.style.background = `linear-gradient(90deg, ${rotationColors.start}, ${rotationColors.end})`;
            rotationBar.style.borderRight = `2px solid ${rotationColors.border}`;
            rotationBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${rotationColors.glow}`;
            document.getElementById('rotationValue').textContent = `${Math.round(rotationPercent)}%`;

            // Kinetics
            const kineticsPercent = Math.max(0, Math.min(100, ((attributes.kinetics - balanceSettings.kinetics.min) / (balanceSettings.kinetics.max - balanceSettings.kinetics.min)) * 100));
            const kineticsBar = document.getElementById('kineticsBar');
            kineticsBar.style.width = `${kineticsPercent}%`;
            const kineticsColors = getColorForPercentage(kineticsPercent);
            kineticsBar.style.background = `linear-gradient(90deg, ${kineticsColors.start}, ${kineticsColors.end})`;
            kineticsBar.style.borderRight = `2px solid ${kineticsColors.border}`;
            kineticsBar.style.boxShadow = `inset 0 0 4px #000, 0 0 6px ${kineticsColors.glow}`;
            document.getElementById('kineticsValue').textContent = `${Math.round(kineticsPercent)}%`;

            // Ammunition (absolute value)
            document.getElementById('ammunitionDisplay').textContent = attributes.ammunition;

            // Update alarm lights
            updateAlarmLights({
                health: healthPercent,
                speed: speedPercent,
                gasoline: gasolinePercent,
                rotation: rotationPercent,
                kinetics: kineticsPercent
            });

            // Update fire button state
            const canFire = playerState.isAlive && attributes.ammunition > 0;
            fireButton.disabled = !canFire;
        }

        // Update alarm lights based on attribute percentages
        function updateAlarmLights(percentages) {
            // Helper function to update alarm state
            function updateAlarmState(alarmElement, percentage) {
                alarmElement.classList.remove('alarm-off', 'alarm-on', 'alarm-flashing', 'alarm-critical');
                
                if (percentage < 5) {
                    // Critical level - fast flashing
                    alarmElement.classList.add('alarm-critical');
                } else if (percentage < 15) {
                    // Low level - flashing
                    alarmElement.classList.add('alarm-flashing');
                } else if (percentage < 25) {
                    // Warning level - solid on
                    alarmElement.classList.add('alarm-on');
                } else {
                    // Normal level - off
                    alarmElement.classList.add('alarm-off');
                }
            }
            
            // Update each alarm light
            updateAlarmState(document.getElementById('healthAlarm'), percentages.health);
            updateAlarmState(document.getElementById('speedAlarm'), percentages.speed);
            updateAlarmState(document.getElementById('rotationAlarm'), percentages.rotation);
            updateAlarmState(document.getElementById('kineticsAlarm'), percentages.kinetics);
        }

        // Show status message
        function showStatus(message, type = 'success') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message show ${type}`;
            setTimeout(() => {
                statusMessage.classList.remove('show');
            }, 3000);
        }

        // Socket event handlers
        socket.on('connect', () => {
            console.log('Socket connected!');
            isConnected = true;
        });
        
        // Debug all socket events
        const originalOn = socket.on;
        socket.on = function(event, callback) {
            console.log('Socket listening for event:', event);
            return originalOn.call(this, event, function(...args) {
                console.log('Socket event received:', event, args);
                if (event === 'joined' || event === 'reconnected') {
                    console.log('=== STATE TRANSITION EVENT ===');
                    console.log('Event type:', event);
                    console.log('Event data:', args);
                }
                return callback.apply(this, args);
            });
        };

        socket.on('disconnect', () => {
            isConnected = false;
            showStatus('Disconnected from server', 'error');
            
            // Reset join button on disconnect
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('joined', (data) => {
            console.log('Joined event received:', data);
            console.log('joinState element:', joinState);
            console.log('playState element:', playState);
            
            // Test DOM manipulation
            console.log('Testing DOM manipulation...');
            console.log('Before - joinState display:', joinState.style.display);
            console.log('Before - playState classes:', playState.className);
            
            joinState.style.display = 'none';
            playState.classList.add('active');
            
            console.log('After state change - joinState display:', joinState.style.display);
            console.log('After state change - playState classes:', playState.className);
            
            // Force a repaint
            playState.offsetHeight;
            
            console.log('After repaint - playState classes:', playState.className);
            console.log('playState computed style display:', window.getComputedStyle(playState).display);
            
            // Add visual indicator
            document.body.style.backgroundColor = '#2a2a2a';
            console.log('Play state activated - controller should be visible!');
            
            // Store player data in localStorage
            localStorage.setItem('tankKillerPlayer', JSON.stringify({
                callname: callnameInput.value.trim(),
                tankColor: selectedBaseColor,
                tankCamo: selectedCamo,
                team: selectedTeam
            }));
            
            // Reset join button
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('reconnected', (data) => {
            console.log('Reconnected event received:', data);
            console.log('Processing reconnected event...');
            showStatus('Reconnected to the game!');
            joinState.style.display = 'none';
            playState.classList.add('active');
            
            console.log('After reconnected state change - joinState display:', joinState.style.display);
            console.log('After reconnected state change - playState classes:', playState.className);
            
            // Reset join button
            joinButton.disabled = false;
            joinButton.textContent = 'Join Game';
        });

        socket.on('playerState', (state) => {
            console.log('Player state received:', state);
            playerState = state;
            updateAttributes(state.attributes);
        });

        socket.on('balanceSettings', (settings) => {
            balanceSettings = settings;
        });

        socket.on('damageFeedback', () => {
            document.body.classList.add('damage-feedback');
            setTimeout(() => {
                document.body.classList.remove('damage-feedback');
            }, 300);
        });

        socket.on('settingsApplied', (data) => {
            showStatus(data.message, 'info');
        });

        socket.on('forceReconnect', (data) => {
            
            // Show notification to user
            showStatus(data.message, 'info');
            
            // Reload the page after a short delay to reconnect with new settings
            setTimeout(() => {
                window.location.reload();
            }, 2000);
        });

        // Load saved player data
        window.addEventListener('load', () => {
            console.log('Window loaded, initializing...');
            console.log('User agent:', navigator.userAgent);
            console.log('Is mobile:', /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
            
            // Debug DOM elements again after load
            console.log('DOM elements after load:');
            console.log('joinState:', joinState);
            console.log('playState:', playState);
            console.log('joinState display:', joinState ? joinState.style.display : 'null');
            console.log('playState classes:', playState ? playState.className : 'null');
            
            // Initialize selections as fallback
            initializeSelections();
            
            const savedPlayer = localStorage.getItem('tankKillerPlayer');
            
            if (savedPlayer) {
                const playerData = JSON.parse(savedPlayer);
                
                // Set saved team or randomize first
                if (playerData.team) {
                    selectedTeam = playerData.team;
                    document.querySelectorAll('.team-option').forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.team === playerData.team) {
                            opt.classList.add('selected');
                        }
                    });
                } else {
                    // Randomize team
                    const teams = ['NATO', 'CSTO', 'PLA'];
                    const randomTeam = teams[Math.floor(Math.random() * teams.length)];
                    console.log('Randomizing team:', randomTeam);
                    selectedTeam = randomTeam;
                    const teamOptions = document.querySelectorAll('.team-option');
                    console.log('Found team options:', teamOptions.length);
                    teamOptions.forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.team === randomTeam) {
                            opt.classList.add('selected');
                            console.log('Selected team option:', opt.dataset.team);
                        }
                    });
                }
                
                // Now generate name based on selected team
                if (playerData.callname && playerData.callname.trim()) {
                    callnameInput.value = playerData.callname;
                } else {
                    // Generate random name based on selected team
                    const randomName = generateRandomName();
                    callnameInput.value = randomName;
                }
                
                // Set saved base color or randomize
                if (playerData.tankColor) {
                    document.querySelectorAll('.base-color-option').forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.color === playerData.tankColor) {
                            opt.classList.add('selected');
                            selectedBaseColor = playerData.tankColor;
                            document.getElementById('selectedColorName').textContent = opt.dataset.name;
                        }
                    });
                } else {
                    // Randomize base color
                    const colorKeys = Object.keys(tankColors);
                    const randomKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
                    const randomColor = tankColors[randomKey];
                    console.log('Randomizing color:', randomColor.label, randomColor.hex);
                    const colorOptions = document.querySelectorAll('.base-color-option');
                    console.log('Found color options:', colorOptions.length);
                    colorOptions.forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.color === randomColor.hex) {
                            opt.classList.add('selected');
                            selectedBaseColor = randomColor.hex;
                            document.getElementById('selectedColorName').textContent = randomColor.label;
                            console.log('Selected color option:', opt.dataset.color);
                        }
                    });
                }

                // Set saved camo or randomize
                if (playerData.tankCamo) {
                    document.querySelectorAll('.camo-option').forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.camo === playerData.tankCamo) {
                            opt.classList.add('selected');
                            selectedCamo = playerData.tankCamo;
                            document.getElementById('selectedCamoName').textContent = opt.dataset.name;
                        }
                    });
                } else {
                    // Randomize camo
                    const camos = Object.keys(tankCamos);
                    const randomCamo = camos[Math.floor(Math.random() * camos.length)];
                    console.log('Randomizing camo:', randomCamo);
                    const camoOptions = document.querySelectorAll('.camo-option');
                    console.log('Found camo options:', camoOptions.length);
                    camoOptions.forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.dataset.camo === randomCamo) {
                            opt.classList.add('selected');
                            selectedCamo = randomCamo;
                            document.getElementById('selectedCamoName').textContent = opt.dataset.name;
                            console.log('Selected camo option:', opt.dataset.camo);
                        }
                    });
                }

                // Update camo backgrounds
                updateCamoBackgrounds();
            } else {
                // No saved data - randomize everything
                // Randomize team first
                const teams = ['NATO', 'CSTO', 'PLA'];
                const randomTeam = teams[Math.floor(Math.random() * teams.length)];
                selectedTeam = randomTeam;
                document.querySelectorAll('.team-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.dataset.team === randomTeam) {
                        opt.classList.add('selected');
                    }
                });
                
                // Now generate name based on selected team
                const randomName = generateRandomName();
                callnameInput.value = randomName;
                
                // Randomize base color
                const colorKeys = Object.keys(tankColors);
                const randomKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
                const randomColor = tankColors[randomKey];
                document.querySelectorAll('.base-color-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.dataset.color === randomColor.hex) {
                        opt.classList.add('selected');
                        selectedBaseColor = randomColor.hex;
                        document.getElementById('selectedColorName').textContent = randomColor.label;
                    }
                });
                
                // Randomize camo
                const camos = Object.keys(tankCamos);
                const randomCamo = camos[Math.floor(Math.random() * camos.length)];
                document.querySelectorAll('.camo-option').forEach(opt => {
                    opt.classList.remove('selected');
                    if (opt.dataset.camo === randomCamo) {
                        opt.classList.add('selected');
                        selectedCamo = randomCamo;
                        document.getElementById('selectedCamoName').textContent = opt.dataset.name;
                    }
                });
                
                // Update camo backgrounds
                updateCamoBackgrounds();
            }
        });

        // Test function to manually trigger state transition
        function testStateTransition() {
            console.log('=== TESTING STATE TRANSITION ===');
            console.log('joinState element:', joinState);
            console.log('playState element:', playState);
            console.log('Before - joinState display:', joinState.style.display);
            console.log('Before - playState classes:', playState.className);
            console.log('Before - playState computed display:', window.getComputedStyle(playState).display);
            
            joinState.style.display = 'none';
            playState.classList.add('active');
            
            console.log('After - joinState display:', joinState.style.display);
            console.log('After - playState classes:', playState.className);
            console.log('After - playState computed display:', window.getComputedStyle(playState).display);
            console.log('After - playState computed visibility:', window.getComputedStyle(playState).visibility);
            console.log('After - playState computed opacity:', window.getComputedStyle(playState).opacity);
            
            // Force a repaint
            playState.offsetHeight;
            console.log('After repaint - playState classes:', playState.className);
            
            // Check if playState is actually visible
            const rect = playState.getBoundingClientRect();
            console.log('playState bounding rect:', rect);
            console.log('playState is visible:', rect.width > 0 && rect.height > 0);
            
            // Check playState content
            console.log('playState children count:', playState.children.length);
            console.log('playState innerHTML length:', playState.innerHTML.length);
            
            // Check if specific elements exist
            const attributeBanner = playState.querySelector('.attribute-banner');
            const fireButton = playState.querySelector('#fireButton');
            const joystickContainer = playState.querySelector('#joystickContainer');
            
            console.log('attributeBanner exists:', !!attributeBanner);
            console.log('fireButton exists:', !!fireButton);
            console.log('joystickContainer exists:', !!joystickContainer);
            
            // Check if elements are visible
            if (attributeBanner) {
                const attrRect = attributeBanner.getBoundingClientRect();
                console.log('attributeBanner computed display:', window.getComputedStyle(attributeBanner).display);
                console.log('attributeBanner bounding rect:', attrRect);
                console.log('attributeBanner dimensions:', attrRect.width, 'x', attrRect.height);
                console.log('attributeBanner position:', attrRect.left, ',', attrRect.top);
            }
            if (fireButton) {
                const fireRect = fireButton.getBoundingClientRect();
                console.log('fireButton computed display:', window.getComputedStyle(fireButton).display);
                console.log('fireButton bounding rect:', fireRect);
                console.log('fireButton dimensions:', fireRect.width, 'x', fireRect.height);
                console.log('fireButton position:', fireRect.left, ',', fireRect.top);
            }
            if (joystickContainer) {
                const joyRect = joystickContainer.getBoundingClientRect();
                console.log('joystickContainer computed display:', window.getComputedStyle(joystickContainer).display);
                console.log('joystickContainer bounding rect:', joyRect);
                console.log('joystickContainer dimensions:', joyRect.width, 'x', joyRect.height);
                console.log('joystickContainer position:', joyRect.left, ',', joyRect.top);
            }
            
            // Check viewport
            console.log('Viewport dimensions:', window.innerWidth, 'x', window.innerHeight);
            console.log('Document scroll position:', window.pageYOffset);
            
            // Check container
            const container = document.querySelector('.container');
            if (container) {
                const containerRect = container.getBoundingClientRect();
                console.log('Container bounding rect:', containerRect);
                console.log('Container dimensions:', containerRect.width, 'x', containerRect.height);
            }
            
            // Check if we need to scroll
            console.log('Play state top position:', rect.top);
            console.log('Viewport height:', window.innerHeight);
            if (rect.top > window.innerHeight) {
                console.log('Play state is below viewport - scrolling needed');
                window.scrollTo(0, rect.top);
            } else {
                console.log('Play state is visible in viewport');
                // Scroll to top to make sure play state is visible
                window.scrollTo(0, 0);
            }
        }

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html> 