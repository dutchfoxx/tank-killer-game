<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battlefield - Tank Killer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #2F2F2F;
            color: #FFFFFF;
            overflow: hidden;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: #1b1b1b;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
        }

        .header h1 {
            color: #b83400;
            font-size: 1.5rem;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .control-button {
            background: none;
            border: none;
            color: #FFFFFF;
            cursor: pointer;
            padding: 8px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .control-button:hover {
            background-color: #555555;
        }

        .control-button.active {
            background-color: #b83400;
        }

        .control-button .material-icons {
            font-size: 20px;
        }

        .game-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #2F2F2F;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        #gameCanvas {
            border: 2px solid #555;
            background-color: #55492f;
            display: block;
            /* Width and height will be set by JavaScript for zoom */
        }

        .settings-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background-color: #1b1b1b;
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            display: none;
        }

        /* FPS Counter */
        .fps-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(27, 27, 27, 0.9);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            border: 1px solid #333;
            transition: all 0.3s ease;
            user-select: none;
            width: 80px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .fps-label {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .fps-value {
            font-size: 16px;
            font-weight: bold;
        }

        .fps-counter:hover {
            background-color: rgba(27, 27, 27, 0.95);
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .fps-value.low {
            color: #ff0000;
        }

        .fps-value.medium {
            color: #ffff00;
        }

        /* Performance Popup */
        .performance-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1b1b1b;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1002;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .performance-popup.show {
            display: block;
        }

        .performance-popup h3 {
            color: #b83400;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .performance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background-color: #2a2a2a;
            border-radius: 5px;
            border-left: 3px solid #555;
        }

        .performance-item.critical {
            border-left-color: #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
        }

        .performance-item.warning {
            border-left-color: #ffff00;
            background-color: rgba(255, 255, 0, 0.1);
        }

        .performance-item.good {
            border-left-color: #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
        }

        .performance-label {
            font-weight: bold;
            color: #ccc;
        }

        .performance-value {
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        .performance-bar {
            width: 100px;
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }

        .performance-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s ease;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
        }

        .popup-overlay.show {
            display: block;
        }

        .close-popup {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .close-popup:hover {
            color: #fff;
        }

        .settings-panel.show {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .settings-header h3 {
            color: #b83400;
        }

        .copy-button {
            background-color: #b83400;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .copy-button:hover {
            background-color: #a03000;
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section h4 {
            color: #CCCCCC;
            margin-bottom: 10px;
            border-bottom: 1px solid #555555;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .set-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .set-button:hover {
            background-color: #45a049;
        }

        .setting-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }

        .setting-item label {
            min-width: 120px;
            flex-shrink: 0;
        }

        .setting-item .set-button {
            flex-shrink: 0;
            width: 40px;
        }

        .setting-item input {
            width: 80px;
            background-color: #555555;
            border: 1px solid #777777;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            text-align: left;
        }

        /* Position input boxes to the right side of the popup */
        .setting-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
            justify-content: space-between;
        }

        /* AI Panel Styles */
        .ai-popup {
            position: fixed;
            top: 70px;
            right: 20px;
            background-color: #1b1b1b;
            border-radius: 10px;
            padding: 20px;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            z-index: 1001;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .ai-popup.show {
            display: block;
        }

        .ai-popup-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .ai-popup-header h3 {
            color: #b83400;
        }

        .ai-popup-close {
            background: none;
            border: none;
            color: #FFFFFF;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            transition: background-color 0.3s ease;
        }

        .ai-popup-close:hover {
            background-color: #555555;
        }

        .ai-popup-close .material-icons {
            font-size: 18px;
        }

        .ai-popup-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .ai-attribute {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .ai-attribute-label {
            min-width: 120px;
            color: #CCCCCC;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .ai-attribute-bar {
            flex: 1;
            height: 8px;
            background-color: #555555;
            border-radius: 4px;
            overflow: hidden;
        }

        .ai-attribute-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 4px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .ai-attribute-fill.low {
            background: linear-gradient(90deg, #f44336, #ff5722);
        }

        .ai-attribute-fill.medium {
            background: linear-gradient(90deg, #ff9800, #ffc107);
        }

        .ai-attribute-fill.high {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
        }

        .ai-attribute-value {
            min-width: 40px;
            color: #FFFFFF;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: right;
        }

        /* Battlefield AI Status Panels */
        .ai-status-panel {
            position: fixed;
            background-color: rgba(27, 27, 27, 0.9);
            border: 2px solid #b83400;
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #CCCCCC;
            z-index: 1000;
            pointer-events: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            width: 180px;
            min-height: 70px;
        }

        .ai-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            border-bottom: 1px solid #555555;
            padding-bottom: 2px;
        }

        .ai-status-name {
            color: #b83400;
            font-weight: bold;
            font-size: 12px;
        }

        .ai-status-level {
            color: #888888;
            font-size: 10px;
        }

        .ai-status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
            font-size: 10px;
        }

        .ai-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-status-label {
            color: #AAAAAA;
        }

        .ai-status-value {
            color: #FFFFFF;
            font-weight: bold;
        }

        .setting-item label {
            min-width: 120px;
            flex-shrink: 0;
        }

        .setting-item .set-button {
            flex-shrink: 0;
            width: 40px;
        }

        .setting-item input {
            width: 80px;
            background-color: #555555;
            border: 1px solid #777777;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            text-align: left;
            margin-left: auto;
        }

        .setting-item label {
            font-size: 0.9rem;
        }




        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }
            
            .settings-panel {
                right: 10px;
                left: 10px;
                max-width: none;
            }
            
            .player-list {
                left: 10px;
                right: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Battlefield</h1>
        <div class="header-controls">
            
            <button class="control-button" id="aiButton">
                <span class="material-icons">smart_toy</span>
                AI
            </button>
            <button class="control-button" id="settingsButton">
                <span class="material-icons">balance</span>
                Balance
            </button>
            <button class="control-button" id="resetButton">
                <span class="material-icons">update</span>
                Reset
            </button>
        </div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <!-- AI Status Panels Container -->
    <div id="aiStatusContainer"></div>

    <!-- AI Panel -->
    <div class="ai-popup" id="aiPopup">
        <div class="ai-popup-header">
            <h3>AI Configuration</h3>
        </div>
        <div class="ai-popup-content">
            <div class="terrain-layer">
                <div class="terrain-layer-header">
                    <h4 class="terrain-layer-title">AI Settings</h4>
                </div>
                <div class="terrain-control">
                    <label>Number of AI:</label>
                    <input type="number" id="aiCount" value="0" min="0" max="10">
                </div>
                <div class="terrain-control">
                    <label>AI Level:</label>
                    <select id="aiLevel">
                        <option value="easy">Easy</option>
                        <option value="intermediate" selected>Intermediate</option>
                        <option value="hard">Hard</option>
                        <option value="insane">Insane</option>
                    </select>
                </div>
            </div>


        </div>
    </div>



    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <button class="copy-button" id="copySettings">Copy</button>
            <button class="copy-button" id="applySettings">Apply</button>
        </div>
        
        <div class="settings-section">
            <h4>Game Parameters</h4>
            <div class="setting-item">
                <label>Respawn Time (ms):</label>
                <input type="number" id="respawnTime" value="5000">
            </div>
            <div class="setting-item">
                <label>Reload Time (ms):</label>
                <input type="number" id="reloadTime" value="1000">
            </div>
            <div class="setting-item">
                <label>Acceleration:</label>
                <input type="number" id="acceleration" value="0.1" step="0.01">
            </div>
            <div class="setting-item">
                        <label>Shell Lifetime (ms):</label>
        <input type="number" id="shellLifetime" value="1000">
            </div>
            <div class="setting-item">
                <label>Gasoline Per Unit:</label>
                <input type="number" id="gasolinePerUnit" value="0.01" step="0.01">
            </div>
            <div class="setting-item">
                <label>Gasoline Speed Penalty:</label>
                <input type="number" id="gasolineSpeedPenalty" value="0.5" step="0.1">
            </div>
        </div>

        <div class="settings-section">
            <h4>Damage Parameters</h4>
            <div class="setting-item">
                <label>Health Damage:</label>
                <input type="number" id="healthDamage" value="1">
            </div>
            <div class="setting-item">
                <label>Speed Damage:</label>
                <input type="number" id="speedDamage" value="5">
            </div>
            <div class="setting-item">
                <label>Rotation Damage:</label>
                <input type="number" id="rotationDamage" value="5">
            </div>
            <div class="setting-item">
                <label>Kinetics Damage:</label>
                <input type="number" id="kineticsDamage" value="10">
            </div>
            <div class="setting-item">
                <label>Gasoline Damage:</label>
                <input type="number" id="gasolineDamage" value="5">
            </div>
        </div>

        <div class="settings-section">
            <h4>Upgrade Counts</h4>
            <div class="setting-item">
                <label>Speed Upgrades:</label>
                <input type="number" id="speedUpgrades" value="1">
            </div>
            <div class="setting-item">
                <label>Gasoline Upgrades:</label>
                <input type="number" id="gasolineUpgrades" value="1">
            </div>
            <div class="setting-item">
                <label>Rotation Upgrades:</label>
                <input type="number" id="rotationUpgrades" value="1">
            </div>
            <div class="setting-item">
                <label>Ammunition Upgrades:</label>
                <input type="number" id="ammunitionUpgrades" value="2">
            </div>
            <div class="setting-item">
                <label>Kinetics Upgrades:</label>
                <input type="number" id="kineticsUpgrades" value="1">
            </div>
            <div class="setting-item">
                <label>Health Upgrades:</label>
                <input type="number" id="healthUpgrades" value="0">
            </div>
        </div>



        <div class="settings-section">
            <h4>Player Attribute Limits</h4>
            <div class="setting-item">
                <label>Min Health:</label>
                <button class="set-button" onclick="setAttribute('health', 'min', event)">Set</button>
                <input type="number" id="minHealth" value="0">
            </div>
            <div class="setting-item">
                <label>Max Health:</label>
                <button class="set-button" onclick="setAttribute('health', 'max', event)">Set</button>
                <input type="number" id="maxHealth" value="100">
            </div>
            <div class="setting-item">
                <label>Min Speed:</label>
                <button class="set-button" onclick="setAttribute('speed', 'min', event)">Set</button>
                <input type="number" id="minSpeed" value="5">
            </div>
            <div class="setting-item">
                <label>Max Speed:</label>
                <button class="set-button" onclick="setAttribute('speed', 'max', event)">Set</button>
                <input type="number" id="maxSpeed" value="50">
            </div>
            <div class="setting-item">
                <label>Min Gasoline:</label>
                <button class="set-button" onclick="setAttribute('gasoline', 'min', event)">Set</button>
                <input type="number" id="minGasoline" value="0">
            </div>
            <div class="setting-item">
                <label>Max Gasoline:</label>
                <button class="set-button" onclick="setAttribute('gasoline', 'max', event)">Set</button>
                <input type="number" id="maxGasoline" value="100">
            </div>
            <div class="setting-item">
                <label>Min Rotation:</label>
                <button class="set-button" onclick="setAttribute('rotation', 'min', event)">Set</button>
                <input type="number" id="minRotation" value="5">
            </div>
            <div class="setting-item">
                <label>Max Rotation:</label>
                <button class="set-button" onclick="setAttribute('rotation', 'max', event)">Set</button>
                <input type="number" id="maxRotation" value="5">
            </div>
            <div class="setting-item">
                <label>Min Ammunition:</label>
                <button class="set-button" onclick="setAttribute('ammunition', 'min', event)">Set</button>
                <input type="number" id="minAmmunition" value="0">
            </div>
            <div class="setting-item">
                <label>Max Ammunition:</label>
                <button class="set-button" onclick="setAttribute('ammunition', 'max', event)">Set</button>
                <input type="number" id="maxAmmunition" value="14">
            </div>
            <div class="setting-item">
                <label>Min Kinetics:</label>
                <button class="set-button" onclick="setAttribute('kinetics', 'min', event)">Set</button>
                <input type="number" id="minKinetics" value="50">
            </div>
            <div class="setting-item">
                <label>Max Kinetics:</label>
                <button class="set-button" onclick="setAttribute('kinetics', 'max', event)">Set</button>
                <input type="number" id="maxKinetics" value="300">
            </div>
        </div>
    </div>

    <!-- Shared Tank Colors Configuration -->
    <script src="/src/shared/tankColors.js"></script>
    <script src="/src/shared/tankCamo.js"></script>
    <script src="/src/shared/shadows.js"></script>

    <script>
        // Update balance popup with current server settings
        function updateBalancePopup() {
            if (balanceSettings) {
                document.getElementById('minHealth').value = balanceSettings.health?.min || 0;
                document.getElementById('maxHealth').value = balanceSettings.health?.max || 100;
                document.getElementById('minSpeed').value = balanceSettings.speed?.min || 15;
                document.getElementById('maxSpeed').value = balanceSettings.speed?.max || 50;
                document.getElementById('minGasoline').value = balanceSettings.gasoline?.min || 0;
                document.getElementById('maxGasoline').value = balanceSettings.gasoline?.max || 100;
                document.getElementById('minRotation').value = balanceSettings.rotation?.min || 5;
                document.getElementById('maxRotation').value = balanceSettings.rotation?.max || 5;
                document.getElementById('minAmmunition').value = balanceSettings.ammunition?.min || 0;
                document.getElementById('maxAmmunition').value = balanceSettings.ammunition?.max || 14;
                document.getElementById('minKinetics').value = balanceSettings.kinetics?.min || 50;
                document.getElementById('maxKinetics').value = balanceSettings.kinetics?.max || 300;
                console.log('Balance popup updated with server settings');
            }
        }

        // Restore applied settings from localStorage if they exist
        function restoreAppliedSettings() {
            const savedSettings = localStorage.getItem('tankKillerAppliedSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    
                    // Restore game parameters
                    if (settings.gameParams) {
                        document.getElementById('respawnTime').value = settings.gameParams.respawnTime || 5000;
                        document.getElementById('reloadTime').value = settings.gameParams.reloadTime || 1000;
                        document.getElementById('acceleration').value = settings.gameParams.acceleration || 0.1;
                        document.getElementById('shellLifetime').value = settings.gameParams.shellLifetime || 1000;
                        document.getElementById('gasolinePerUnit').value = settings.gameParams.gasolinePerUnit || 2.0;
                        document.getElementById('gasolineSpeedPenalty').value = settings.gameParams.gasolineSpeedPenalty || 0.5;
                    }
                    
                    // Restore damage parameters
                    if (settings.damageParams) {
                        document.getElementById('healthDamage').value = settings.damageParams.health || 1;
                        document.getElementById('speedDamage').value = settings.damageParams.speed || 5;
                        document.getElementById('rotationDamage').value = settings.damageParams.rotation || 5;
                        document.getElementById('kineticsDamage').value = settings.damageParams.kinetics || 10;
                        document.getElementById('gasolineDamage').value = settings.damageParams.gasoline || 5;
                    }
                    
                    // Restore upgrade counts
                    if (settings.upgradeTypes) {
                        document.getElementById('speedUpgrades').value = settings.upgradeTypes.speed?.count || 1;
                        document.getElementById('gasolineUpgrades').value = settings.upgradeTypes.gasoline?.count || 1;
                        document.getElementById('rotationUpgrades').value = settings.upgradeTypes.rotation?.count || 1;
                        document.getElementById('ammunitionUpgrades').value = settings.upgradeTypes.ammunition?.count || 2;
                        document.getElementById('kineticsUpgrades').value = settings.upgradeTypes.kinetics?.count || 1;
                        document.getElementById('healthUpgrades').value = settings.upgradeTypes.health?.count || 0;
                    }
                    

                    

                    
                    // Note: Balance settings are now handled by updateBalancePopup() from server
                    
                    console.log('Applied settings restored from localStorage');
                } catch (error) {
                    console.error('Error restoring settings:', error);
                }
            }
        }
        
        // Call restoration function on page load
        restoreAppliedSettings();
        
        // Game state
        let gameState = {
            players: [],
            tanks: [],
            shells: [],
            upgrades: [],
            trees: [],
            gameTime: 0
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to match game dimensions
        function setupCanvas() {
            // Get device pixel ratio for high-DPI displays
            const devicePixelRatio = window.devicePixelRatio || 1;
            
            // Calculate optimal canvas size based on game arena - keep perfect gameplay size
            const maxWidth = 1500; // Original perfect game arena width
            const maxHeight = 900;  // Original perfect game arena height
            
            // Set display size (CSS pixels) - use optimized size
            const displayWidth = maxWidth;
            const displayHeight = maxHeight;
            
            // Set actual canvas size in memory (use reasonable scaling for performance)
            // Limit device pixel ratio to avoid excessive memory usage
            const limitedPixelRatio = Math.min(devicePixelRatio, 1.2);
            canvas.width = displayWidth * limitedPixelRatio;
            canvas.height = displayHeight * limitedPixelRatio;
            
            // Calculate zoom factor to fill screen real estate
            const screenWidth = window.innerWidth - 40;
            const screenHeight = window.innerHeight - 100;
            const scaleX = screenWidth / displayWidth;
            const scaleY = screenHeight / displayHeight;
            const zoomFactor = Math.min(scaleX, scaleY, 2.0); // Cap at 2x zoom max
            
            // Scale the canvas to fill screen real estate
            canvas.style.width = (displayWidth * zoomFactor) + 'px';
            canvas.style.height = (displayHeight * zoomFactor) + 'px';
            
            // Store zoom factor for persistence
            canvas.dataset.zoomFactor = zoomFactor;
            
            console.log(`Canvas zoomed: ${displayWidth}x${displayHeight} -> ${(displayWidth * zoomFactor).toFixed(0)}x${(displayHeight * zoomFactor).toFixed(0)} (${zoomFactor.toFixed(2)}x zoom)`);
            
            // Scale the drawing context so everything draws at the correct size
            ctx.scale(limitedPixelRatio, limitedPixelRatio);
            
            // Improve image rendering quality for high-res images
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium'; // Changed from 'high' to 'medium' for better performance
            
            console.log(`Canvas optimized: ${displayWidth}x${displayHeight} (${canvas.width}x${canvas.height} with limited DPI scaling)`);
            console.log(`Window size: ${window.innerWidth}x${window.innerHeight}`);
            console.log(`Device pixel ratio: ${devicePixelRatio} (limited to ${limitedPixelRatio})`);
            console.log(`Canvas style size: ${canvas.style.width} x ${canvas.style.height}`);
        }
        
        setupCanvas();

        // Socket connection
        const socket = io();
        
        // Debug socket connection
        socket.on('connect', () => {
            console.log('[DEBUG] Battlefield connected to server');
        });
        
        socket.on('disconnect', () => {
            console.log('[DEBUG] Battlefield disconnected from server');
        });

        // UI elements
        const settingsButton = document.getElementById('settingsButton');
        const settingsPanel = document.getElementById('settingsPanel');
        const aiButton = document.getElementById('aiButton');

        const copySettingsButton = document.getElementById('copySettings');
        const applySettingsButton = document.getElementById('applySettings');
        const aiPopup = document.getElementById('aiPopup');
        const aiPopupClose = document.getElementById('aiPopupClose');


        let aiEnabled = false;
        let aiTankId = null;

        // Simple terrain defaults (no editing)
        const terrainDefaults = {
            mudColor: '#70543e',
            grassColor: '#394428',
            upgradeSize: 22.5
        };

        // Tree images
        const treeImages = {
            tree1: null,
            tree2: null,
            tree3: null
        };

        // Upgrade images
        const upgradeImages = {
            SPEED: null,
            GASOLINE: null,
            ROTATION: null,
            AMMUNITION: null,
            KINETICS: null,
            HEALTH: null
        };

        // Load tree images
        function loadTreeImages() {
            const treePaths = {
                tree1: '/assets/images/terrain/objects/forest-tree-1.png',
                tree2: '/assets/images/terrain/objects/forest-tree-2.png',
                tree3: '/assets/images/terrain/objects/forest-tree-3.png'
            };

            Object.entries(treePaths).forEach(([key, path]) => {
                const img = new Image();
                img.onload = function() {
                    treeImages[key] = img;
                    console.log('Loaded tree image:', key, 'Size:', img.width, 'x', img.height);
                };
                img.onerror = function() {
                    console.error('Failed to load tree image:', key, path);
                };
                img.src = path;
            });
        }

        // Load upgrade images
        function loadUpgradeImages() {
            const upgradePaths = {
                SPEED: '/assets/images/upgrades/speed-1.png',
                GASOLINE: '/assets/images/upgrades/gasoline-1.png',
                ROTATION: '/assets/images/upgrades/rotation-1.png',
                AMMUNITION: '/assets/images/upgrades/ammo-1.png',
                KINETICS: '/assets/images/upgrades/kinetics-1.png',
                HEALTH: '/assets/images/upgrades/health-1.png' // Will need to create this
            };

            Object.entries(upgradePaths).forEach(([key, path]) => {
                const img = new Image();
                img.onload = function() {
                    upgradeImages[key] = img;
                    console.log('Loaded upgrade image:', key, 'Size:', img.width, 'x', img.height);
                };
                img.onerror = function() {
                    console.error('Failed to load upgrade image:', key, path);
                    // Fallback will be handled in renderUpgrade function
                };
                img.src = path;
            });
        }

        // Initialize tree images and upgrade images
        loadTreeImages();
        loadUpgradeImages();



        // Balance button toggle
        settingsButton.addEventListener('click', () => {
            // Close other popups first
            aiPopup.classList.remove('show');
            
            settingsPanel.classList.toggle('show');
        });

        // AI button toggle
        aiButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Close other popups first
            settingsPanel.classList.remove('show');
            
            // Toggle AI panel
            aiPopup.classList.toggle('show');
        });





        // AI settings change handlers (auto-apply)
        document.getElementById('aiCount').addEventListener('input', () => {
            const aiCount = parseInt(document.getElementById('aiCount').value) || 0;
            const aiLevel = document.getElementById('aiLevel').value;
            
            console.log('AI settings changed:', { aiCount, aiLevel });
            socket.emit('applyAISettings', { aiCount, aiLevel });
        });

        document.getElementById('aiLevel').addEventListener('change', () => {
            const aiCount = parseInt(document.getElementById('aiCount').value) || 0;
            const aiLevel = document.getElementById('aiLevel').value;
            
            console.log('AI settings changed:', { aiCount, aiLevel });
            socket.emit('applyAISettings', { aiCount, aiLevel });
        });

        // AI Status Panel Management
        const aiStatusPanels = new Map();

        function createAIStatusPanel(aiId, tank, player) {
            const panel = document.createElement('div');
            panel.className = 'ai-status-panel';
            panel.id = `ai-status-${aiId}`;
            
            const level = document.getElementById('aiLevel').value;
            
            panel.innerHTML = `
                <div class="ai-status-header">
                    <span class="ai-status-name">${player.callname}</span>
                    <span class="ai-status-level">${level} - ${player.strategy || 'Unknown'}</span>
                </div>
                <div class="ai-status-grid">
                    <div class="ai-status-item">
                        <span class="ai-status-label">Health</span>
                        <span class="ai-status-value" id="ai-${aiId}-health">${Math.round(tank.attributes.health)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Rotation</span>
                        <span class="ai-status-value" id="ai-${aiId}-rotation">${Math.round(tank.attributes.rotation)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Speed</span>
                        <span class="ai-status-value" id="ai-${aiId}-speed">${Math.round(tank.attributes.speed)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Kinetics</span>
                        <span class="ai-status-value" id="ai-${aiId}-kinetics">${Math.round(tank.attributes.kinetics)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Gasoline</span>
                        <span class="ai-status-value" id="ai-${aiId}-gasoline">${Math.round(tank.attributes.gasoline)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Ammo</span>
                        <span class="ai-status-value" id="ai-${aiId}-ammo">${Math.round(tank.attributes.ammunition)}</span>
                    </div>
                </div>
            `;
            
            document.getElementById('aiStatusContainer').appendChild(panel);
            aiStatusPanels.set(aiId, panel);
            
            return panel;
        }

        function updateAIStatusPanel(aiId, tank) {
            const panel = aiStatusPanels.get(aiId);
            if (!panel) return;
            
            // Update values
            const healthEl = panel.querySelector(`#ai-${aiId}-health`);
            const rotationEl = panel.querySelector(`#ai-${aiId}-rotation`);
            const speedEl = panel.querySelector(`#ai-${aiId}-speed`);
            const kineticsEl = panel.querySelector(`#ai-${aiId}-kinetics`);
            const gasolineEl = panel.querySelector(`#ai-${aiId}-gasoline`);
            const ammoEl = panel.querySelector(`#ai-${aiId}-ammo`);
            
            if (healthEl) healthEl.textContent = Math.round(tank.attributes.health) + '%';
            if (rotationEl) rotationEl.textContent = Math.round(tank.attributes.rotation) + '%';
            if (speedEl) speedEl.textContent = Math.round(tank.attributes.speed) + '%';
            if (kineticsEl) kineticsEl.textContent = Math.round(tank.attributes.kinetics) + '%';
            if (gasolineEl) gasolineEl.textContent = Math.round(tank.attributes.gasoline) + '%';
            if (ammoEl) ammoEl.textContent = Math.round(tank.attributes.ammunition);
        }

        function removeAIStatusPanel(aiId) {
            const panel = aiStatusPanels.get(aiId);
            if (panel) {
                panel.remove();
                aiStatusPanels.delete(aiId);
            }
        }

        function updateAIStatusPanelPositions() {
            if (!gameState.tanks) return;
            
            const canvas = document.getElementById('gameCanvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Get all AI tanks and sort them by ID for consistent positioning
            const aiTanks = gameState.tanks.filter(t => t.id.startsWith('ai_')).sort((a, b) => a.id.localeCompare(b.id));
            
            aiTanks.forEach((tank, index) => {
                const panel = aiStatusPanels.get(tank.id);
                if (!panel) return;
                
                // Convert tank position to screen coordinates
                const screenX = (tank.position.x / 1500) * canvasRect.width; // Use actual game width
                const screenY = (tank.position.y / 900) * canvasRect.height; // Use actual game height
                
                // Position panels side by side at the top of the screen
                const panelWidth = 200; // Approximate panel width
                const panelHeight = 80; // Approximate panel height
                const margin = 10;
                
                // Calculate horizontal position to avoid overlap
                const maxPanelsPerRow = Math.floor(canvasRect.width / (panelWidth + margin));
                const row = Math.floor(index / maxPanelsPerRow);
                const col = index % maxPanelsPerRow;
                
                const left = col * (panelWidth + margin) + margin;
                const top = row * (panelHeight + margin) + margin;
                
                panel.style.left = `${left}px`;
                panel.style.top = `${top}px`;
                panel.style.position = 'fixed'; // Use fixed positioning for consistent layout
            });
        }

        // Function to create AI status panels for existing AI tanks
        function createAIStatusPanelsForExistingTanks() {
            if (!gameState.tanks || !gameState.players) return;
            
            // Count existing AI tanks and update the input
            const aiTanks = gameState.tanks.filter(tank => tank.id.startsWith('ai_'));
            const aiCountInput = document.getElementById('aiCount');
            if (aiCountInput && aiTanks.length > 0) {
                aiCountInput.value = aiTanks.length.toString();
            }
            
            gameState.tanks.forEach(tank => {
                if (tank.id.startsWith('ai_') && !aiStatusPanels.has(tank.id)) {
                    const player = gameState.players.find(p => p.id === tank.id);
                    if (player) {
                        createAIStatusPanel(tank.id, tank, player);
                    }
                }
            });
        }



        // Reset button functionality
        resetButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('[DEBUG] Reset button clicked - emitting resetGame event');
            socket.emit('resetGame');
            
            // Reset local state
            aiEnabled = false;
            aiTankId = null;
            aiButton.classList.remove('active');
            aiPopup.classList.remove('show');
            
            // Reset AI count to 0
            document.getElementById('aiCount').value = '0';
            
            // Clear all AI status panels
            aiStatusPanels.forEach((panel, aiId) => {
                removeAIStatusPanel(aiId);
            });
        });

        // Copy balance parameters
        copySettingsButton.addEventListener('click', () => {
            const settings = {
                gameParams: {
                    respawnTime: parseInt(document.getElementById('respawnTime').value),
                    reloadTime: parseInt(document.getElementById('reloadTime').value),
                    acceleration: parseFloat(document.getElementById('acceleration').value),
                    shellLifetime: parseInt(document.getElementById('shellLifetime').value),
                    gasolinePerUnit: parseFloat(document.getElementById('gasolinePerUnit').value),
                    gasolineSpeedPenalty: parseFloat(document.getElementById('gasolineSpeedPenalty').value)
                },
                damageParams: {
                    health: parseInt(document.getElementById('healthDamage').value),
                    speed: parseInt(document.getElementById('speedDamage').value),
                    rotation: parseInt(document.getElementById('rotationDamage').value),
                    kinetics: parseInt(document.getElementById('kineticsDamage').value),
                    gasoline: parseInt(document.getElementById('gasolineDamage').value)
                },
                upgradeTypes: {
                    speed: { count: parseInt(document.getElementById('speedUpgrades').value) },
                    gasoline: { count: parseInt(document.getElementById('gasolineUpgrades').value) },
                    rotation: { count: parseInt(document.getElementById('rotationUpgrades').value) },
                    ammunition: { count: parseInt(document.getElementById('ammunitionUpgrades').value) },
                    kinetics: { count: parseInt(document.getElementById('kineticsUpgrades').value) },
                    health: { count: parseInt(document.getElementById('healthUpgrades').value) }
                },
                attributeLimits: {
                    health: {
                        min: parseInt(document.getElementById('minHealth').value),
                        max: parseInt(document.getElementById('maxHealth').value)
                    },
                    speed: {
                        min: parseInt(document.getElementById('minSpeed').value),
                        max: parseInt(document.getElementById('maxSpeed').value)
                    },
                    gasoline: {
                        min: parseInt(document.getElementById('minGasoline').value),
                        max: parseInt(document.getElementById('maxGasoline').value)
                    },
                    rotation: {
                        min: parseInt(document.getElementById('minRotation').value),
                        max: parseInt(document.getElementById('maxRotation').value)
                    },
                    ammunition: {
                        min: parseInt(document.getElementById('minAmmunition').value),
                        max: parseInt(document.getElementById('maxAmmunition').value)
                    },
                    kinetics: {
                        min: parseInt(document.getElementById('minKinetics').value),
                        max: parseInt(document.getElementById('maxKinetics').value)
                    }
                }
            };

            navigator.clipboard.writeText(JSON.stringify(settings, null, 2)).then(() => {
                copySettingsButton.textContent = 'Copied!';
                setTimeout(() => {
                    copySettingsButton.textContent = 'Copy';
                }, 2000);
            });
        });



        // Individual attribute setter function
        function setAttribute(attributeName, type, event) {
            try {
                // Construct the correct element ID
                const elementId = type + attributeName.charAt(0).toUpperCase() + attributeName.slice(1);
                const element = document.getElementById(elementId);
                
                if (!element) {
                    console.error('Element not found:', elementId);
                    return;
                }
                
                const value = parseInt(element.value);
                
                const attributeUpdate = {
                    attributeName: attributeName,
                    value: value,
                    type: type  // 'min' or 'max'
                };
                
                socket.emit('setPlayerAttributeLimit', attributeUpdate);
                
                // Visual feedback on the clicked button
                if (event && event.target) {
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = 'Set!';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 2000);
                }
            } catch (error) {
                console.error('Error in setAttribute function:', error);
            }
        }

        // Apply balance parameters
        applySettingsButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('[LOG] Apply settings button clicked');
            const settings = {
                gameParams: {
                    respawnTime: parseInt(document.getElementById('respawnTime').value),
                    reloadTime: parseInt(document.getElementById('reloadTime').value),
                    acceleration: parseFloat(document.getElementById('acceleration').value),
                    shellLifetime: parseInt(document.getElementById('shellLifetime').value),
                    gasolinePerUnit: parseFloat(document.getElementById('gasolinePerUnit').value),
                    gasolineSpeedPenalty: parseFloat(document.getElementById('gasolineSpeedPenalty').value)
                },
                damageParams: {
                    health: parseInt(document.getElementById('healthDamage').value),
                    speed: parseInt(document.getElementById('speedDamage').value),
                    rotation: parseInt(document.getElementById('rotationDamage').value),
                    kinetics: parseInt(document.getElementById('kineticsDamage').value),
                    gasoline: parseInt(document.getElementById('gasolineDamage').value)
                },
                upgradeTypes: {
                    speed: { count: parseInt(document.getElementById('speedUpgrades').value) },
                    gasoline: { count: parseInt(document.getElementById('gasolineUpgrades').value) },
                    rotation: { count: parseInt(document.getElementById('rotationUpgrades').value) },
                    ammunition: { count: parseInt(document.getElementById('ammunitionUpgrades').value) },
                    kinetics: { count: parseInt(document.getElementById('kineticsUpgrades').value) },
                    health: { count: parseInt(document.getElementById('healthUpgrades').value) }
                },
                attributeLimits: {
                    health: {
                        min: parseInt(document.getElementById('minHealth').value),
                        max: parseInt(document.getElementById('maxHealth').value)
                    },
                    speed: {
                        min: parseInt(document.getElementById('minSpeed').value),
                        max: parseInt(document.getElementById('maxSpeed').value)
                    },
                    gasoline: {
                        min: parseInt(document.getElementById('minGasoline').value),
                        max: parseInt(document.getElementById('maxGasoline').value)
                    },
                    rotation: {
                        min: parseInt(document.getElementById('minRotation').value),
                        max: parseInt(document.getElementById('maxRotation').value)
                    },
                    ammunition: {
                        min: parseInt(document.getElementById('minAmmunition').value),
                        max: parseInt(document.getElementById('maxAmmunition').value)
                    },
                    kinetics: {
                        min: parseInt(document.getElementById('minKinetics').value),
                        max: parseInt(document.getElementById('maxKinetics').value)
                    }
                }
            };

            // Send settings to server to apply (without forced reset unless needed)
            socket.emit('applySettings', settings);
            
            // Visual feedback
            applySettingsButton.textContent = 'Applied!';
            setTimeout(() => {
                applySettingsButton.textContent = 'Apply';
            }, 2000);
        });



        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('requestGameState');
        });

        // Store balance settings received from server
        let balanceSettings = {
            health: { min: 0, max: 100 },
            speed: { min: 15, max: 50 },
            gasoline: { min: 0, max: 100 },
            rotation: { min: 5, max: 5 },
            ammunition: { min: 0, max: 14 },
            kinetics: { min: 50, max: 300 }
        };

            socket.on('gameState', (data) => {
            gameState = data;
            
            // Create AI status panels for existing AI tanks
            createAIStatusPanelsForExistingTanks();
            
            // Update AI status panels
            if (data.tanks) {
                data.tanks.forEach(tank => {
                    if (tank.id.startsWith('ai_')) {
                        updateAIStatusPanel(tank.id, tank);
                    }
                });
                updateAIStatusPanelPositions();
            }
        });

        socket.on('balanceSettings', (settings) => {
            console.log('Balance settings received:', settings);
            balanceSettings = settings;
            updateBalancePopup();
        });

        socket.on('aiAdded', (data) => {
            console.log('[DEBUG] aiAdded event received:', data);
            aiTankId = data.aiId;
            
            // Create AI status panel when AI is added
            if (gameState.tanks && gameState.players) {
                const tank = gameState.tanks.find(t => t.id === data.aiId);
                const player = gameState.players.find(p => p.id === data.aiId);
                if (tank && player) {
                    createAIStatusPanel(data.aiId, tank, player);
                }
            }
        });

        socket.on('aiRemoved', (data) => {
            console.log('[DEBUG] aiRemoved event received:', data);
            aiTankId = null;
            
            // Remove AI status panel when AI is removed
            removeAIStatusPanel(data.aiId);
        });

        socket.on('gameReset', (data) => {
            console.log('[DEBUG] gameReset event received:', data);
            console.log('[DEBUG] Game state after reset:', {
                trees: gameState.trees?.length || 0,
                tanks: gameState.tanks?.length || 0,
                shells: gameState.shells?.length || 0,
                upgrades: gameState.upgrades?.length || 0
            });
            
            // Reset notification removed - no more annoying popup!
        });

        socket.on('settingsApplied', (data) => {
            console.log('[DEBUG] settingsApplied event received:', data);
            // Show a notification without forcing reconnection
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                z-index: 1000;
                font-family: Arial, sans-serif;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;
            notification.textContent = data.message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        });

        socket.on('forceReconnect', (data) => {
            console.log('[DEBUG] forceReconnect event received - THIS WAS THE PROBLEM!', data);
            // This event should now be rare and only used for critical updates
        });

        socket.on('attributesSet', (data) => {
            if (data.success) {
                console.log('Player attributes set successfully');
                // Show a brief notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #4CAF50;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 5px;
                    z-index: 1000;
                    font-family: Arial, sans-serif;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;
                notification.textContent = 'Player attributes set!';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 2000);
            }
        });

        socket.on('forceReconnect', (data) => {
            console.log('Force reconnection requested:', data.message);
            
            // Store current settings in localStorage before reloading
            const currentSettings = {
                gameParams: {
                    respawnTime: parseInt(document.getElementById('respawnTime').value),
                    reloadTime: parseInt(document.getElementById('reloadTime').value),
                    acceleration: parseFloat(document.getElementById('acceleration').value),
                    shellLifetime: parseInt(document.getElementById('shellLifetime').value),
                    gasolinePerUnit: parseFloat(document.getElementById('gasolinePerUnit').value),
                    gasolineSpeedPenalty: parseFloat(document.getElementById('gasolineSpeedPenalty').value)
                },
                damageParams: {
                    health: parseInt(document.getElementById('healthDamage').value),
                    speed: parseInt(document.getElementById('speedDamage').value),
                    rotation: parseInt(document.getElementById('rotationDamage').value),
                    kinetics: parseInt(document.getElementById('kineticsDamage').value),
                    gasoline: parseInt(document.getElementById('gasolineDamage').value)
                },
                upgradeTypes: {
                    speed: { count: parseInt(document.getElementById('speedUpgrades').value) },
                    gasoline: { count: parseInt(document.getElementById('gasolineUpgrades').value) },
                    rotation: { count: parseInt(document.getElementById('rotationUpgrades').value) },
                    ammunition: { count: parseInt(document.getElementById('ammunitionUpgrades').value) },
                    kinetics: { count: parseInt(document.getElementById('kineticsUpgrades').value) },
                    health: { count: parseInt(document.getElementById('healthUpgrades').value) }
                },
                attributeLimits: {
                    health: {
                        min: parseInt(document.getElementById('minHealth').value),
                        max: parseInt(document.getElementById('maxHealth').value)
                    },
                    speed: {
                        min: parseInt(document.getElementById('minSpeed').value),
                        max: parseInt(document.getElementById('maxSpeed').value)
                    },
                    gasoline: {
                        min: parseInt(document.getElementById('minGasoline').value),
                        max: parseInt(document.getElementById('maxGasoline').value)
                    },
                    rotation: {
                        min: parseInt(document.getElementById('minRotation').value),
                        max: parseInt(document.getElementById('maxRotation').value)
                    },
                    ammunition: {
                        min: parseInt(document.getElementById('minAmmunition').value),
                        max: parseInt(document.getElementById('maxAmmunition').value)
                    },
                    kinetics: {
                        min: parseInt(document.getElementById('minKinetics').value),
                        max: parseInt(document.getElementById('maxKinetics').value)
                    }
                }
            };
            
            // Store settings in localStorage
            localStorage.setItem('tankKillerAppliedSettings', JSON.stringify(currentSettings));
            
            // Show notification to user
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 15px 20px;
                border-radius: 5px;
                z-index: 1000;
                font-family: Arial, sans-serif;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;
            notification.textContent = data.message;
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
            
            // Reload the page after a short delay to reconnect with new settings
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        });



        // Tank texture mapping - will be loaded from shared config
        let tankTextures = {};
        
        // Shell animation sprite
        let shellSprite = null;
        const shellSpriteImage = new Image();
        shellSpriteImage.onload = function() {
            shellSprite = this;
            console.log('Shell sprite loaded:', this.width, 'x', this.height);
        };
        shellSpriteImage.onerror = function() {
            console.error('Failed to load shell sprite');
        };
        shellSpriteImage.src = '/assets/images/shells/shell-animation.png?t=' + Date.now(); // Cache bust

        // Load tank textures from shared config
        tankTextures = tankCamos;
        
        // Preload tank textures
        const tankTextureImages = {};
        console.log('Loading tank textures:', tankTextures);
        Object.entries(tankTextures).forEach(([key, info]) => {
            const img = new Image();
            img.onload = function() {
                tankTextureImages[key] = img;
                console.log('Loaded texture:', key, info.texture);
            };
            img.onerror = function() {
                console.error('Failed to load texture:', key, info.texture);
            };
            img.src = `/assets/images/${info.texture}`;
        });

        // Tank images - simplified layered system
        let tankBodyContours = null;
        let tankBodyColorMap = null;
        let tankTurretContours = null;
        let tankTurretBaseColorMap = null;
        let tankTurretGunneryColorMap = null;

        // Load tank images
        function loadTankImages() {
            console.log('Loading tank images...');
            
            // Load contour images
            const tankBodyContoursImage = new Image();
            tankBodyContoursImage.onload = function() {
                tankBodyContours = this;
                console.log('Loaded tank body contours');
            };
            tankBodyContoursImage.onerror = function() {
                console.error('Failed to load tank body contours');
            };
            tankBodyContoursImage.src = '/assets/images/tanks/body_contours.png';

            const tankTurretContoursImage = new Image();
            tankTurretContoursImage.onload = function() {
                tankTurretContours = this;
                console.log('Loaded tank turret contours');
            };
            tankTurretContoursImage.onerror = function() {
                console.error('Failed to load tank turret contours');
            };
            tankTurretContoursImage.src = '/assets/images/tanks/turret_contours.png';

            // Load color map images
            const tankBodyColorMapImage = new Image();
            tankBodyColorMapImage.onload = function() {
                tankBodyColorMap = this;
                console.log('Loaded tank body color map');
            };
            tankBodyColorMapImage.onerror = function() {
                console.error('Failed to load tank body color map');
            };
            tankBodyColorMapImage.src = '/assets/images/tanks/bodyBase_colourMap.png';

            const tankTurretBaseColorMapImage = new Image();
            tankTurretBaseColorMapImage.onload = function() {
                tankTurretBaseColorMap = this;
                console.log('Loaded tank turret base color map');
            };
            tankTurretBaseColorMapImage.onerror = function() {
                console.error('Failed to load tank turret base color map');
            };
            tankTurretBaseColorMapImage.src = '/assets/images/tanks/turretBase_colourMap.png';

            const tankTurretGunneryColorMapImage = new Image();
            tankTurretGunneryColorMapImage.onload = function() {
                tankTurretGunneryColorMap = this;
                console.log('Loaded tank turret gunnery color map');
            };
            tankTurretGunneryColorMapImage.onerror = function() {
                console.error('Failed to load tank turret gunnery color map');
            };
            tankTurretGunneryColorMapImage.src = '/assets/images/tanks/turretGunnery_colourMap.png';
        }

        // Load tank images on startup
        loadTankImages();

        // Helper functions for tank rendering
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function getCamoPixel(x, y, pattern, scale) {
            if (!camoTextureData[pattern]) return 0;
            const data = camoTextureData[pattern];
            const scaledX = Math.floor(x * scale) % 256;
            const scaledY = Math.floor(y * scale) % 256;
            const index = (scaledY * 256 + scaledX) * 4;
            return data[index] / 255; // Return grayscale value
        }

        function applyCamoBlend(pixelR, pixelG, pixelB, camoValue, blendMode, opacity) {
            const camoR = camoValue * 255;
            const camoG = camoValue * 255;
            const camoB = camoValue * 255;
            
            let newR, newG, newB;
            
            switch (blendMode) {
                case 'overlay-pixel':
                    newR = pixelR < 128 ? (2 * pixelR * camoR) / 255 : 255 - (2 * (255 - pixelR) * (255 - camoR)) / 255;
                    newG = pixelG < 128 ? (2 * pixelG * camoG) / 255 : 255 - (2 * (255 - pixelG) * (255 - camoG)) / 255;
                    newB = pixelB < 128 ? (2 * pixelB * camoB) / 255 : 255 - (2 * (255 - pixelB) * (255 - camoB)) / 255;
                    break;
                default:
                    newR = pixelR;
                    newG = pixelG;
                    newB = pixelB;
            }
            
            // Apply opacity
            newR = pixelR + (newR - pixelR) * opacity;
            newG = pixelG + (newG - pixelG) * opacity;
            newB = pixelB + (newB - pixelB) * opacity;
            
            return [newR, newG, newB];
        }

        // Pre-process camo textures for performance
        const camoTextureData = {};
        Object.entries(tankTextures).forEach(([key, info]) => {
            if (info.texture) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 256;
                    ctx.drawImage(img, 0, 0, 256, 256);
                    camoTextureData[key] = ctx.getImageData(0, 0, 256, 256).data;
                };
                img.src = `/assets/images/${info.texture}`;
            }
        });

        // Render functions - Exact copy from tank.html
        function drawCamoLayer(image, centerX, centerY, scale, layerType = 'body') {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            // For camo layers, draw normally preserving transparency and blend mode
            ctx.drawImage(image, x, y, width, height);
        }

        function drawTankLayer(image, centerX, centerY, scale, isColorMap = false, layerType = 'body', player = null) {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            if (isColorMap && player) {
                // For color maps, apply pixel-level color manipulation
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                
                // Draw the original image
                tempCtx.drawImage(image, 0, 0);
                
                // Get image data for manipulation
                const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;
                
                // Convert hex color to RGB and HSL
                const hexColor = player.tankColor || '#888888';
                const targetR = parseInt(hexColor.slice(1, 3), 16);
                const targetG = parseInt(hexColor.slice(3, 5), 16);
                const targetB = parseInt(hexColor.slice(5, 7), 16);
                const targetHsl = rgbToHsl(targetR, targetG, targetB);
                
                // Apply pixel-level color manipulation (hard-light-pixel as default)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // If pixel is not transparent
                        const pixelR = data[i];
                        const pixelG = data[i + 1];
                        const pixelB = data[i + 2];
                        const pixelA = data[i + 3];
                        
                        // Apply hard-light-pixel blending
                        let newR, newG, newB;
                        newR = targetR < 128 ? (2 * pixelR * targetR) / 255 : 255 - (2 * (255 - pixelR) * (255 - targetR)) / 255;
                        newG = targetG < 128 ? (2 * pixelG * targetG) / 255 : 255 - (2 * (255 - pixelG) * (255 - targetG)) / 255;
                        newB = targetB < 128 ? (2 * pixelB * targetB) / 255 : 255 - (2 * (255 - pixelB) * (255 - targetB)) / 255;
                        
                        data[i] = Math.max(0, Math.min(255, Math.round(newR)));
                        data[i + 1] = Math.max(0, Math.min(255, Math.round(newG)));
                        data[i + 2] = Math.max(0, Math.min(255, Math.round(newB)));
                        data[i + 3] = pixelA; // Keep original alpha
                    }
                }
                
                // Put the modified image data back
                tempCtx.putImageData(imageData, 0, 0);
                
                // Apply dual shadows using the new shadow system (FOR COLOR MAPS)
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx);
                    ctx.drawImage(tempCanvas, x, y, width, height);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx);
                    ctx.drawImage(tempCanvas, x, y, width, height);
                } else {
                    // Fallback to legacy shadow if new system not available
                    applyShadow(ctx, 'DEFAULT');
                    ctx.drawImage(tempCanvas, x, y, width, height);
                }
                
                // Draw the modified image (shadows are already drawn above)
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(tempCanvas, x, y, width, height);
                
            } else {
                // For contours, draw normally preserving transparency (NO SHADOWS)
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(image, x, y, width, height);
            }
            
            // Reset shadow settings after drawing
            if (typeof resetShadows !== 'undefined') {
                resetShadows(ctx);
            } else {
                // Fallback reset
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
        }

        // Helper functions for color conversion (exact copy from tank.html)
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [
                Math.round(r * 255),
                Math.round(g * 255),
                Math.round(b * 255)
            ];
        }

        // Helper function to determine if a color is light (exact copy from tank.html)
        function isColorLight(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.4; // Threshold for light colors
        }

        // Helper function to load camo images
        function loadCamoImage(camoType, layerType) {
            const image = new Image();
            image.src = `/assets/images/textures/camo/${layerType}_${camoType}.png`;
            
            // Store in window for reuse
            if (layerType === 'base') {
                window.camoBaseImage = image;
            } else if (layerType === 'turret') {
                window.camoTurretImage = image;
            }
            
            return image;
        }

        function renderTank(tank, player) {
            if (!tank.isAlive) return;

            // Check if tank images are loaded
            if (!tankBodyContours || !tankBodyColorMap) {
                // Fallback to simple rendering if images aren't loaded
                ctx.save();
                ctx.translate(tank.position.x, tank.position.y);
                ctx.rotate(tank.angle);
                
                let tankColor = '#888888'; // Default gray for AI
                if (player) {
                    tankColor = player.tankColor;
                } else if (tank.isAI) {
                    tankColor = '#888888'; // Specific gray for AI tanks
                }
                
                ctx.fillStyle = tankColor;
                ctx.fillRect(-10, -10, 20, 20);
                
                // Tank barrel
                ctx.fillStyle = '#333333';
                ctx.fillRect(0, -2, 15, 4);
                
                ctx.restore();
                return;
            }

            // Draw tank body (rotated)
            ctx.save();
            ctx.translate(tank.position.x, tank.position.y);
            ctx.rotate(tank.angle);

            const scale = 0.067; // Match tank designer scale
            const centerX = 0;
            const centerY = 0; // Back to center rotation point

            // Draw tank layers in order (back to front) - Exact copy from tank.html
            // 1. Body color map (furthest back)
            drawTankLayer(tankBodyColorMap, centerX, centerY, scale, true, 'body', player);
            
            // 2. Body camo (if available) - above base, below elements
            if (player && player.tankCamo && player.tankCamo !== 'none') {
                // Load camo images if not already loaded
                const camoBaseImage = window.camoBaseImage || loadCamoImage(player.tankCamo, 'base');
                if (camoBaseImage) {
                    ctx.save();
                    ctx.globalAlpha = 0.8; // Default camo opacity
                    
                    // Auto-set blend mode based on tank color brightness
                    const currentColor = player.tankColor || '#888888';
                    const isLightColor = isColorLight(currentColor);
                    const autoBlendMode = isLightColor ? 'multiply' : 'soft-light';
                    
                    ctx.globalCompositeOperation = autoBlendMode;
                    drawCamoLayer(camoBaseImage, centerX, centerY, scale, 'body');
                    ctx.restore();
                }
            }
            
            // 3. Body contours
            drawTankLayer(tankBodyContours, centerX, centerY, scale, false, 'body', player);
            
            // 4. Turret base color map (if available)
            if (tankTurretBaseColorMap) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(tank.turretAngle || 0);
                drawTankLayer(tankTurretBaseColorMap, 0, 0, scale, true, 'turret', player);
                ctx.restore();
            }
            
            // 5. Turret camo (if available) - above base, below gunnery
            if (player && player.tankCamo && player.tankCamo !== 'none') {
                const camoTurretImage = window.camoTurretImage || loadCamoImage(player.tankCamo, 'turret');
                if (camoTurretImage) {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(tank.turretAngle || 0);
                    ctx.globalAlpha = 0.8; // Default camo opacity
                    
                    // Auto-set blend mode based on tank color brightness
                    const currentColor = player.tankColor || '#888888';
                    const isLightColor = isColorLight(currentColor);
                    const autoBlendMode = isLightColor ? 'multiply' : 'soft-light';
                    
                    ctx.globalCompositeOperation = autoBlendMode;
                    drawCamoLayer(camoTurretImage, 0, 0, scale, 'turret');
                    ctx.restore();
                }
            }
            
            // 6. Turret gunnery color map (if available)
            if (tankTurretGunneryColorMap) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(tank.turretAngle || 0);
                drawTankLayer(tankTurretGunneryColorMap, 0, 0, scale, true, 'turret', player);
                ctx.restore();
            }
            
            // 7. Turret contours (if available)
            if (tankTurretContours) {
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(tank.turretAngle || 0);
                drawTankLayer(tankTurretContours, 0, 0, scale, false, 'turret', player);
                ctx.restore();
            }

            ctx.restore();

            // Draw name, health bar, and team (not rotated)
            ctx.save();
            ctx.translate(tank.position.x, tank.position.y - 35);

            if (player) {
                // Player name (above)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.callname, 0, -5);

                // Health bar background (underneath)
                ctx.fillStyle = '#1b1b1b';
                ctx.fillRect(-20, 5, 40, 6);

                // Health bar
                const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
                ctx.fillStyle = healthPercent > 50 ? '#4CAF50' : healthPercent > 25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, 5, (healthPercent / 100) * 40, 6);
            } else if (tank.isAI) {
                // AI tank - show "AI" label and health bar
                ctx.fillStyle = '#FF6B6B';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('AI', 0, -5);

                // Health bar background (underneath)
                ctx.fillStyle = '#1b1b1b';
                ctx.fillRect(-20, 5, 40, 6);

                // Health bar
                const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
                ctx.fillStyle = healthPercent > 50 ? '#4CAF50' : healthPercent > 25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, 5, (healthPercent / 100) * 40, 6);
            }

            ctx.restore();
        }

        function renderShell(shell) {
            ctx.save();
            ctx.translate(shell.position.x, shell.position.y);

            // Shell trail
            const trailLength = 13;
            // Calculate magnitude manually since velocity loses methods after network transmission
            const velocityMagnitude = Math.sqrt(shell.velocity.x * shell.velocity.x + shell.velocity.y * shell.velocity.y);
            
            if (velocityMagnitude > 0) {
                // Calculate trail start position relative to shell position (since we're already translated)
                const trailStartX = -shell.velocity.x * trailLength / velocityMagnitude;
                const trailStartY = -shell.velocity.y * trailLength / velocityMagnitude;

                const gradient = ctx.createLinearGradient(trailStartX, trailStartY, 0, 0);
                gradient.addColorStop(0, 'rgba(104, 105, 82, 0)'); // #686952 with 0 opacity
                gradient.addColorStop(1, 'rgba(104, 105, 82, 0.8)'); // #686952 with 0.8 opacity

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(trailStartX, trailStartY);
                ctx.lineTo(0, 0);
                ctx.stroke();
            }

            // Calculate shell rotation based on velocity direction
            const shellAngle = Math.atan2(shell.velocity.y, shell.velocity.x);
            ctx.rotate(shellAngle);

            // Use animated shell sprite if available
            if (shellSprite) {
                // Animate based on shell velocity or time
                const frameCount = 6; // 6 frames in the sprite sheet
                const frameWidth = 50; // Each frame is 50px wide
                const frameHeight = 50; // Each frame is 50px tall
                
                // Use velocity magnitude to determine animation speed
                const animationSpeed = Math.min(velocityMagnitude / 50, 2); // Faster animation
                const time = Date.now() * animationSpeed;
                const currentFrame = Math.floor(time) % frameCount;
                
                // Draw the current frame (vertical layout)
                const sourceX = 0; // All frames are in the same column
                const sourceY = currentFrame * frameHeight; // Each frame is stacked vertically
                const destWidth = 11; // Shell size from settings
                const destHeight = 11;
                
                ctx.drawImage(
                    shellSprite,
                    sourceX, sourceY, frameWidth, frameHeight,
                    -destWidth/2, -destHeight/2, destWidth, destHeight
                );
            } else {
                // Fallback to geometric shell if sprite not loaded
                const shellLength = 8;
                const shellWidth = 3;
                const tipLength = 3;
                const backLength = 2;
                
                // Draw shell body
                ctx.fillStyle = '#797a62';
                ctx.beginPath();
                const bodyX = shellLength/2 - tipLength - (shellLength - tipLength - backLength);
                const bodyY = -shellWidth/2;
                const bodyWidth = shellLength - tipLength - backLength;
                const bodyHeight = shellWidth;
                const radius = shellWidth/2;
                
                ctx.moveTo(bodyX + radius, bodyY);
                ctx.lineTo(bodyX + bodyWidth - radius, bodyY);
                ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY, bodyX + bodyWidth, bodyY + radius);
                ctx.lineTo(bodyX + bodyWidth, bodyY + bodyHeight - radius);
                ctx.quadraticCurveTo(bodyX + bodyWidth, bodyY + bodyHeight, bodyX + bodyWidth - radius, bodyY + bodyHeight);
                ctx.lineTo(bodyX + radius, bodyY + bodyHeight);
                ctx.quadraticCurveTo(bodyX, bodyY + bodyHeight, bodyX, bodyY + bodyHeight - radius);
                ctx.lineTo(bodyX, bodyY + radius);
                ctx.quadraticCurveTo(bodyX, bodyY, bodyX + radius, bodyY);
                ctx.closePath();
                ctx.fill();
                
                // Draw shell tip
                ctx.fillStyle = '#5e5e58';
                ctx.beginPath();
                ctx.moveTo(shellLength/2, 0);
                ctx.lineTo(shellLength/2 - tipLength, -shellWidth/2);
                ctx.lineTo(shellLength/2 - tipLength, shellWidth/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw shell back
                const backGradient = ctx.createLinearGradient(-shellLength/2, 0, -shellLength/2 + backLength, 0);
                backGradient.addColorStop(0, '#312404');
                backGradient.addColorStop(0.5, '#ecc77d');
                backGradient.addColorStop(1, '#7b581b');
                
                ctx.fillStyle = backGradient;
                ctx.fillRect(-shellLength/2, -shellWidth/2, backLength, shellWidth);
            }

            ctx.restore();
        }



        function renderUpgrade(upgrade) {
            if (upgrade.collected) return;

            ctx.save();
            ctx.translate(upgrade.position.x, upgrade.position.y);
            
            // Apply random rotation if available
            if (upgrade.rotation !== undefined) {
                ctx.rotate(upgrade.rotation);
            }

            const upgradeImage = upgradeImages[upgrade.type];
            const size = terrainDefaults.upgradeSize;

            if (upgradeImage) {
                // Calculate image size with proper aspect ratio
                const imageAspectRatio = upgradeImage.width / upgradeImage.height;
                const scaledWidth = size;
                const scaledHeight = size / imageAspectRatio;
                
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx);
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx);
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT'); // Fallback to legacy shadow
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                }
                ctx.restore();
                
                // Draw the main upgrade image
                ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
            } else {
                // Fallback to original style if image not loaded
                // Enhanced fallback with new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT'); // Fallback to legacy shadow
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else {
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                }
                ctx.restore();
                
                // Main upgrade background
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(-size/2, -size/2, size, size);

                // Upgrade symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(upgrade.type.charAt(0), 0, 0);
            }

            ctx.restore();
        }

        function renderTree(tree) {
            ctx.save();
            ctx.translate(tree.position.x, tree.position.y);

            // Apply swing animation with static random rotation offset
            // Tree trunk circle (1/6th of tree size) - centered in tree and rendered behind leaves in black
            ctx.save();
            ctx.fillStyle = 'black'; // Black trunk
            ctx.beginPath();
            ctx.arc(0, -tree.size/2, tree.size / 6, 0, Math.PI * 2); // Centered in the leaves circle
            ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.translate(0, -tree.size/2); // Move to foliage center
            ctx.translate(tree.foliageOffsetX || 0, tree.foliageOffsetY || 0); // Apply translation offset
            ctx.rotate(tree.leafRotation); // Apply static random rotation first
            ctx.rotate(tree.swingAngle || 0); // Then apply dynamic swing animation
            
            // Tree foliage using actual tree images
            // Tree type and rotation are now initialized on the server side
            const treeImage = treeImages[tree.treeType];
            
            if (treeImage) {
                // Calculate image size based on tree size
                const imageSize = tree.size;
                const imageAspectRatio = treeImage.width / treeImage.height;
                const scaledWidth = imageSize;
                const scaledHeight = imageSize / imageAspectRatio;
                
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx);
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx);
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT'); // Fallback to legacy shadow
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                }
                ctx.restore();
                
                // Draw the main tree image
                ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
            } else {
                // Fallback to simple circle if image not loaded
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx);
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx);
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT'); // Fallback to legacy shadow
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                
                // Draw main foliage
                ctx.fillStyle = '#5e6936';
                ctx.beginPath();
                ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore(); // Restore foliage transform

            ctx.restore();
        }

        // Simple terrain rendering with defaults
        function renderTerrain() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Simple terrain background using defaults
            ctx.fillStyle = terrainDefaults.mudColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Main render loop
        function render() {
            // Render terrain layers
            renderTerrain();

            // Render upgrades (background layer)
            if (gameState.upgrades && Array.isArray(gameState.upgrades)) {
                gameState.upgrades.forEach(renderUpgrade);
            }



                    // Render shells
        if (gameState.shells && Array.isArray(gameState.shells)) {
            gameState.shells.forEach(renderShell);
        }

                    // Render tanks
        if (gameState.tanks && Array.isArray(gameState.tanks)) {
            // Create a map of players for O(1) lookup instead of O(n) find
            const playerMap = new Map();
            if (gameState.players && Array.isArray(gameState.players)) {
                gameState.players.forEach(player => playerMap.set(player.id, player));
            }
            
            gameState.tanks.forEach(tank => {
                const player = playerMap.get(tank.id) || null;
                renderTank(tank, player);
            });
        }

            // Render trees (foreground layer - above tanks)
            if (gameState.trees && Array.isArray(gameState.trees)) {
                gameState.trees.forEach(renderTree);
            }

            requestAnimationFrame(render);
        }

        // Start rendering
        render();
    </script>

    <!-- FPS Counter -->
    <div class="fps-counter" id="fpsCounter">
        <div class="fps-label">FPS</div>
        <div class="fps-value" id="fpsValue">60</div>
    </div>

    <!-- Performance Popup Overlay -->
    <div class="popup-overlay" id="popupOverlay"></div>

    <!-- Performance Popup -->
    <div class="performance-popup" id="performancePopup">
        <button class="close-popup" id="closePopup">&times;</button>
        <h3>Performance Monitor</h3>
        <div id="performanceContent">
            <!-- Performance items will be dynamically generated here -->
        </div>
    </div>

    <script>
        // FPS Counter and Performance Monitoring
        let fpsCounter = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let fpsHistory = [];
        const maxFpsHistory = 60;
        let fpsUpdateCounter = 0;
        const fpsUpdateInterval = 10; // Update FPS display every 10 frames (roughly 6 times per second at 60fps)
        
        // Cache DOM elements for performance
        const fpsElement = document.getElementById('fpsCounter');
        const fpsValueElement = document.getElementById('fpsValue');

        // Performance monitoring
        let performanceData = {
            fps: { current: 0, average: 0, min: 0, max: 0 },
            memory: { used: 0, total: 0, percentage: 0 },
            renderTime: { current: 0, average: 0 },
            gameObjects: { tanks: 0, shells: 0, trees: 0, upgrades: 0 },
            network: { latency: 0, packetsPerSecond: 0 }
        };

        // FPS Counter Update
        function updateFPS() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            
            if (deltaTime > 0) {
                const currentFPS = 1000 / deltaTime;
                fpsHistory.push(currentFPS);
                
                if (fpsHistory.length > maxFpsHistory) {
                    fpsHistory.shift();
                }
                
                const averageFPS = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
                const minFPS = Math.min(...fpsHistory);
                const maxFPS = Math.max(...fpsHistory);
                
                performanceData.fps = {
                    current: Math.round(currentFPS),
                    average: Math.round(averageFPS),
                    min: Math.round(minFPS),
                    max: Math.round(maxFPS)
                };
                
                // Only update display every few frames to reduce jitter
                fpsUpdateCounter++;
                if (fpsUpdateCounter >= fpsUpdateInterval) {
                    // Use a smoother average for display
                    const recentFPS = fpsHistory.slice(-10); // Last 10 frames
                    const displayFPS = Math.round(recentFPS.reduce((a, b) => a + b, 0) / recentFPS.length);
                    
                    // Update FPS counter display
                    fpsValueElement.textContent = displayFPS;
                    
                    // Color coding based on FPS
                    fpsValueElement.classList.remove('low', 'medium');
                    if (displayFPS < 30) {
                        fpsValueElement.classList.add('low');
                    } else if (displayFPS < 50) {
                        fpsValueElement.classList.add('medium');
                    }
                    
                    fpsUpdateCounter = 0; // Reset counter
                }
                
                // Auto-enable performance mode if FPS is critically low
                // DISABLED: This was overriding the zoom. User wants to maintain zoom regardless of FPS.
                /*
                if (performanceData.fps.current < 15 && !performanceMode && fpsHistory.length > 10) {
                    console.log('Auto-enabling performance mode due to low FPS');
                    performanceMode = true;
                    
                    const ultraMaxWidth = 1200;
                    const ultraMaxHeight = 800;
                    
                    canvas.width = ultraMaxWidth * (window.devicePixelRatio || 1);
                    canvas.height = ultraMaxHeight * (window.devicePixelRatio || 1);
                    
                    // Calculate reduced zoom for auto-performance mode
                    const screenWidth = window.innerWidth - 40;
                    const screenHeight = window.innerHeight - 100;
                    const scaleX = screenWidth / ultraMaxWidth;
                    const scaleY = screenHeight / ultraMaxHeight;
                    const zoomFactor = Math.min(scaleX, scaleY, 1.5); // Reduced zoom cap for performance
                    
                    canvas.style.width = (ultraMaxWidth * zoomFactor) + 'px';
                    canvas.style.height = (ultraMaxHeight * zoomFactor) + 'px';
                    
                    fpsElement.style.color = '#ff6600';
                    fpsElement.textContent = `FPS: ${performanceData.fps.current} (AUTO PERF)`;
                }
                */
            }
            
            lastTime = currentTime;
            requestAnimationFrame(updateFPS);
        }

        // Performance Monitoring
        function updatePerformanceData() {
            // Memory usage (if available)
            if (performance.memory) {
                const memory = performance.memory;
                performanceData.memory = {
                    used: Math.round(memory.usedJSHeapSize / 1024 / 1024),
                    total: Math.round(memory.totalJSHeapSize / 1024 / 1024),
                    percentage: Math.round((memory.usedJSHeapSize / memory.totalJSHeapSize) * 100)
                };
            }

            // Game objects count
            if (gameState) {
                performanceData.gameObjects = {
                    tanks: gameState.tanks ? gameState.tanks.length : 0,
                    shells: gameState.shells ? gameState.shells.length : 0,
                    trees: gameState.trees ? gameState.trees.length : 0,
                    upgrades: gameState.upgrades ? gameState.upgrades.length : 0
                };
            }

            // Network latency (if socket is available)
            if (socket && socket.connected) {
                const startTime = performance.now();
                socket.emit('ping', () => {
                    const latency = performance.now() - startTime;
                    performanceData.network.latency = Math.round(latency);
                });
            }

            // Update every second
            setTimeout(updatePerformanceData, 1000);
        }

        // Generate performance report
        function generatePerformanceReport() {
            const content = document.getElementById('performanceContent');
            content.innerHTML = '';

            // FPS Section
            addPerformanceItem(content, 'Current FPS', `${performanceData.fps.current}`, performanceData.fps.current, 60);
            addPerformanceItem(content, 'Average FPS', `${performanceData.fps.average}`, performanceData.fps.average, 60);
            addPerformanceItem(content, 'Min FPS', `${performanceData.fps.min}`, performanceData.fps.min, 60);
            addPerformanceItem(content, 'Max FPS', `${performanceData.fps.max}`, performanceData.fps.max, 60);

            // Memory Section
            if (performanceData.memory.used > 0) {
                addPerformanceItem(content, 'Memory Used', `${performanceData.memory.used} MB`, performanceData.memory.percentage, 100);
                addPerformanceItem(content, 'Memory Total', `${performanceData.memory.total} MB`, 100, 100);
            }

            // Game Objects Section
            addPerformanceItem(content, 'Tanks', `${performanceData.gameObjects.tanks}`, performanceData.gameObjects.tanks, 50);
            addPerformanceItem(content, 'Shells', `${performanceData.gameObjects.shells}`, performanceData.gameObjects.shells, 100);
            addPerformanceItem(content, 'Trees', `${performanceData.gameObjects.trees}`, performanceData.gameObjects.trees, 200);
            addPerformanceItem(content, 'Upgrades', `${performanceData.gameObjects.upgrades}`, performanceData.gameObjects.upgrades, 50);

            // Network Section
            if (performanceData.network.latency > 0) {
                addPerformanceItem(content, 'Network Latency', `${performanceData.network.latency}ms`, performanceData.network.latency, 100);
            }

            // System Info
            addPerformanceItem(content, 'Screen Resolution', `${window.screen.width}x${window.screen.height}`, 100, 100);
            addPerformanceItem(content, 'Canvas Size', `${canvas.width}x${canvas.height}`, 100, 100);
            
            // Canvas optimization info
            const canvasPixels = canvas.width * canvas.height;
            const maxRecommended = 1500 * 900; // 1.35M pixels for game arena
            addPerformanceItem(content, 'Canvas Pixels', `${(canvasPixels / 1000000).toFixed(1)}M`, canvasPixels, maxRecommended);
            
            // Zoom info
            const zoomFactor = parseFloat(canvas.style.width) / 1500;
            addPerformanceItem(content, 'Visual Zoom', `${zoomFactor.toFixed(2)}x`, zoomFactor * 100, 200);
            
            // Performance recommendations
            if (performanceData.fps.current < 20) {
                addPerformanceItem(content, 'RECOMMENDATION', 'Double-click FPS counter for performance mode', 100, 100);
            }
            
            // Add refresh button for canvas optimization
            const refreshButton = document.createElement('button');
            refreshButton.textContent = 'Force Canvas Optimization';
            refreshButton.style.cssText = `
                background: #b83400;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                margin-top: 10px;
                width: 100%;
            `;
            refreshButton.onclick = () => {
                setupCanvas();
                generatePerformanceReport();
            };
            content.appendChild(refreshButton);
            
            addPerformanceItem(content, 'User Agent', navigator.userAgent.substring(0, 50) + '...', 100, 100);
        }

        function addPerformanceItem(container, label, value, current, max) {
            const item = document.createElement('div');
            item.className = 'performance-item';
            
            const percentage = Math.min((current / max) * 100, 100);
            
            if (percentage > 80) {
                item.classList.add('critical');
            } else if (percentage > 60) {
                item.classList.add('warning');
            } else {
                item.classList.add('good');
            }

            item.innerHTML = `
                <div class="performance-label">${label}</div>
                <div class="performance-value">${value}</div>
                <div class="performance-bar">
                    <div class="performance-bar-fill" style="width: ${percentage}%"></div>
                </div>
            `;
            
            container.appendChild(item);
        }

        // Popup controls
        document.getElementById('fpsCounter').addEventListener('click', () => {
            generatePerformanceReport();
            document.getElementById('performancePopup').classList.add('show');
            document.getElementById('popupOverlay').classList.add('show');
        });

        document.getElementById('closePopup').addEventListener('click', () => {
            document.getElementById('performancePopup').classList.remove('show');
            document.getElementById('popupOverlay').classList.remove('show');
        });

        document.getElementById('popupOverlay').addEventListener('click', () => {
            document.getElementById('performancePopup').classList.remove('show');
            document.getElementById('popupOverlay').classList.remove('show');
        });

        // Performance mode toggle
        let performanceMode = false;
        
        // Add performance mode button to FPS counter
        document.getElementById('fpsCounter').addEventListener('dblclick', () => {
            performanceMode = !performanceMode;
            if (performanceMode) {
                // Enable performance mode - reduce zoom for better performance
                const ultraMaxWidth = 1200;
                const ultraMaxHeight = 800;
                
                canvas.width = ultraMaxWidth * (window.devicePixelRatio || 1);
                canvas.height = ultraMaxHeight * (window.devicePixelRatio || 1);
                
                // Calculate reduced zoom for performance mode
                const screenWidth = window.innerWidth - 40;
                const screenHeight = window.innerHeight - 100;
                const scaleX = screenWidth / ultraMaxWidth;
                const scaleY = screenHeight / ultraMaxHeight;
                const zoomFactor = Math.min(scaleX, scaleY, 1.5); // Reduced zoom cap for performance
                
                canvas.style.width = (ultraMaxWidth * zoomFactor) + 'px';
                canvas.style.height = (ultraMaxHeight * zoomFactor) + 'px';
                
                fpsElement.style.color = '#ff6600';
                fpsElement.textContent = `FPS: ${performanceData.fps.current} (PERF MODE)`;

            } else {
                // Disable performance mode - restore normal size
                setupCanvas();
                fpsElement.style.color = '#00ff00';

            }
        });
        
        // Function to maintain zoom
        function maintainZoom() {
            if (canvas.dataset.zoomFactor) {
                const zoomFactor = parseFloat(canvas.dataset.zoomFactor);
                const baseWidth = 1500;
                const baseHeight = 900;
                const expectedWidth = (baseWidth * zoomFactor) + 'px';
                const expectedHeight = (baseHeight * zoomFactor) + 'px';
                
                // Reapply zoom if it was reset
                if (canvas.style.width !== expectedWidth || canvas.style.height !== expectedHeight) {
                    canvas.style.width = expectedWidth;
                    canvas.style.height = expectedHeight;

                }
            }
        }
        
        // Start monitoring
        updateFPS();
        updatePerformanceData();
        
        // Debug: Watch for canvas style changes
        const canvasObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && (mutation.attributeName === 'style')) {
                    // Debug logging removed for performance
                }
            });
        });
        
        canvasObserver.observe(canvas, { attributes: true, attributeFilter: ['style'] });
        
        // Don't maintain zoom automatically - let it be set once and stay
        // setInterval(maintainZoom, 1000);
    </script>
</body>
</html> 