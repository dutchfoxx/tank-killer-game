<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battlefield - Tank Killer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #2F2F2F;
            color: #FFFFFF;
            overflow: hidden;
        }

        .reset-button {
            position: fixed;
            top: 0px;
            right: 0px;
            background: none;
            border: none;
            color: #FFFFFF;
            cursor: pointer;
            padding: 8px 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 1000;
        }

        .reset-button:hover {
            opacity: 0.8;
        }

        .reset-button .material-icons {
            font-size: 18px;
        }

        /* Logo Styles */
        .logo-container {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1002;
            text-align: center;
        }

        .logo {
            max-width: 200px;
            height: auto;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .game-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #2F2F2F;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }

        #gameCanvas {
            border: 2px solid #555;
            background-color: #55492f;
            display: block;
            /* Width and height will be set by JavaScript for zoom */
        }



        /* FPS Counter */
        .fps-counter {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(27, 27, 27, 0.9);
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            border: 1px solid #333;
            transition: all 0.3s ease;
            user-select: none;
            width: 80px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        
        .fps-label {
            font-size: 10px;
            opacity: 0.8;
        }
        
        .fps-value {
            font-size: 16px;
            font-weight: bold;
        }

        .fps-counter:hover {
            background-color: rgba(27, 27, 27, 0.95);
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .fps-value.low {
            color: #ff0000;
        }

        .fps-value.medium {
            color: #ffff00;
        }

        /* Performance Popup */
        .performance-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #1b1b1b;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            max-width: 500px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1002;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }

        .performance-popup.show {
            display: block;
        }

        .performance-popup h3 {
            color: #b83400;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .performance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background-color: #2a2a2a;
            border-radius: 5px;
            border-left: 3px solid #555;
        }

        .performance-item.critical {
            border-left-color: #ff0000;
            background-color: rgba(255, 0, 0, 0.1);
        }

        .performance-item.warning {
            border-left-color: #ffff00;
            background-color: rgba(255, 255, 0, 0.1);
        }

        .performance-item.good {
            border-left-color: #00ff00;
            background-color: rgba(0, 255, 0, 0.1);
        }

        .performance-label {
            font-weight: bold;
            color: #ccc;
        }

        .performance-value {
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        .performance-bar {
            width: 100px;
            height: 8px;
            background-color: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-left: 10px;
        }

        .performance-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s ease;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1001;
            display: none;
        }

        .popup-overlay.show {
            display: block;
        }

        .close-popup {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }

        .close-popup:hover {
            color: #fff;
        }



        /* AI Control Panel Styles */
        .ai-control-panel {
            position: fixed;
            top: 0px;
            left: 0px;
            padding: 12px;
            min-width: 180px;
            z-index: 1001;
        }

        .ai-control-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 12px;
            color: #FFFFFF;
            font-weight: bold;
            font-size: 13px;
        }

        .ai-control-header .material-icons {
            font-size: 16px;
            color: #FFFFFF;
        }

        .ai-level-selector {
            margin-bottom: 8px;
            margin-top: 4px;
        }

        .ai-level-dropdown {
            width: 100px;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: #333333;
            color: #FFFFFF;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ai-level-dropdown:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .ai-level-dropdown:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.7);
            background: rgba(255, 255, 255, 0.2);
        }

        .ai-level-dropdown option {
            background: #2a2a2a;
            color: #FFFFFF;
        }

        .ai-control-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .ai-control-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .ai-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .ai-control-btn:active {
            transform: scale(0.95);
        }

        .ai-list {
            max-height: 250px;
            padding-top: 8px;
        }

        .ai-entry {
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .ai-entry-name {
            color: #FFFFFF;
            font-weight: bold;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .ai-attribute-line {
            color: rgba(255, 255, 255, 0.8);
            font-size: 10px;
            margin: 1px 0;
        }

        /* Battlefield AI Status Panels */
        .ai-status-panel {
            position: fixed;
            background-color: rgba(27, 27, 27, 0.9);
            border: 2px solid #b83400;
            border-radius: 8px;
            padding: 8px 12px;
            font-family: Arial, sans-serif;
            font-size: 11px;
            color: #CCCCCC;
            z-index: 1000;
            pointer-events: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            width: 180px;
            min-height: 70px;
        }

        .ai-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            border-bottom: 1px solid #555555;
            padding-bottom: 2px;
        }

        .ai-status-name {
            color: #b83400;
            font-weight: bold;
            font-size: 12px;
        }

        .ai-status-level {
            color: #888888;
            font-size: 10px;
        }

        .ai-status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px 12px;
            font-size: 10px;
        }

        .ai-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-status-label {
            color: #AAAAAA;
        }

        .ai-status-value {
            color: #FFFFFF;
            font-weight: bold;
        }

        .setting-item label {
            min-width: 120px;
            flex-shrink: 0;
        }

        .setting-item .set-button {
            flex-shrink: 0;
            width: 40px;
        }

        .setting-item input {
            width: 80px;
            background-color: #555555;
            border: 1px solid #777777;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            text-align: left;
            margin-left: auto;
        }

        .setting-item label {
            font-size: 0.9rem;
        }




        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }
            
            .settings-panel {
                right: 10px;
                left: 10px;
                max-width: none;
            }
            
            .player-list {
                left: 10px;
                right: 10px;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <!-- Logo -->
    <div class="logo-container">
        <img src="/assets/branding/logo/tank-killer-logo.png" alt="Tank Killer" class="logo">
    </div>

    <button class="reset-button" id="resetButton">
        <span class="material-icons">update</span>
        Reset
    </button>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <!-- AI Status Panels Container -->
    <div id="aiStatusContainer"></div>

    <!-- AI Control Panel -->
    <div class="ai-control-panel" id="aiControlPanel">
        <div class="ai-control-header">
            <span class="material-icons">smart_toy</span>
            AI
        </div>
        <div class="ai-level-selector">
            <select id="aiLevelSelect" class="ai-level-dropdown">
                <option value="easy">Easy</option>
                <option value="intermediate" selected>Intermediate</option>
                <option value="hard">Hard</option>
                <option value="insane">Insane</option>
            </select>
        </div>
        <div class="ai-control-buttons">
            <button class="ai-control-btn" id="aiMinusBtn">-</button>
            <button class="ai-control-btn" id="aiPlusBtn">+</button>
        </div>
        <div class="ai-list" id="aiList">
            <!-- AI entries will be dynamically generated here -->
        </div>
    </div>





    <!-- Shared Tank Colors Configuration -->
    <script src="/src/shared/tankColors.js"></script>
    <script src="/src/shared/tankCamo.js"></script>
    <script src="/src/shared/shadows.js"></script>

    <script>



        
        // Game state
        let gameState = {
            players: [],
            tanks: [],
            shells: [],
            upgrades: [],
            trees: [],
            gameTime: 0
        };

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Terrain cache variables (declared early for setupCanvas)
        let terrainCanvas = null;
        let terrainCtx = null;
        let terrainRendered = false;
        
        // Tank sprite cache system for massive performance boost
        const tankSpriteCache = new Map(); // Cache key -> {canvas, lastUsed}
        const maxCacheSize = 50; // Limit cache size to prevent memory bloat
        let cacheHitCount = 0;
        let cacheMissCount = 0;
        
        // Shell optimization system
        const shellSpriteCache = new Map(); // Cache shell sprites by rotation angle
        const trailGradientCache = new Map(); // Cache trail gradients
        let shellRenderCount = 0;
        let shellCacheHits = 0;
        let animationTime = 0; // Shared animation timer
        const maxShellCacheSize = 200; // More shells need bigger cache
        
        // Set canvas size to match game dimensions
        function setupCanvas() {
            // Get device pixel ratio for high-DPI displays
            const devicePixelRatio = window.devicePixelRatio || 1;
            
            // Calculate optimal canvas size based on game arena - keep perfect gameplay size
            const maxWidth = 1500; // Original perfect game arena width
            const maxHeight = 900;  // Original perfect game arena height
            
            // Set display size (CSS pixels) - use optimized size
            const displayWidth = maxWidth;
            const displayHeight = maxHeight;
            
            // Set actual canvas size in memory (use reasonable scaling for performance)
            // Limit device pixel ratio to 1.0 to avoid excessive memory usage and improve performance
            const limitedPixelRatio = Math.min(devicePixelRatio, 1.0);
            canvas.width = displayWidth * limitedPixelRatio;
            canvas.height = displayHeight * limitedPixelRatio;
            
            // Calculate zoom factor to fill screen real estate
            const screenWidth = window.innerWidth - 40;
            const screenHeight = window.innerHeight - 100;
            const scaleX = screenWidth / displayWidth;
            const scaleY = screenHeight / displayHeight;
            const zoomFactor = Math.min(scaleX, scaleY, 2.0); // Cap at 2x zoom max
            
            // Scale the canvas to fill screen real estate
            canvas.style.width = (displayWidth * zoomFactor) + 'px';
            canvas.style.height = (displayHeight * zoomFactor) + 'px';
            
            // Store zoom factor for persistence
            canvas.dataset.zoomFactor = zoomFactor;
            
            // Removed canvas zoom logging to clean up console
            
            // Scale the drawing context so everything draws at the correct size
            ctx.scale(limitedPixelRatio, limitedPixelRatio);
            
            // Improve image rendering quality for high-res images
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'medium'; // Changed from 'high' to 'medium' for better performance
            
                    // Removed canvas optimization logging to clean up console
            
            // Invalidate terrain cache when canvas size changes
            terrainRendered = false;
        }
        
        setupCanvas();

        // Socket connection
        const socket = io();
        
        // Debug socket connection
        socket.on('connect', () => {
            // Removed connection logging to clean up console
        });
        
        socket.on('disconnect', () => {
            // Removed disconnection logging to clean up console
        });

        // UI elements
        const aiControlPanel = document.getElementById('aiControlPanel');
        const aiList = document.getElementById('aiList');
        const aiPlusBtn = document.getElementById('aiPlusBtn');
        const aiMinusBtn = document.getElementById('aiMinusBtn');
        const aiLevelSelect = document.getElementById('aiLevelSelect');

        let aiCount = 0; // Start with 0 AI
        let aiLevel = 'intermediate';

        // Simple terrain defaults (no editing)
        const terrainDefaults = {
            mudColor: '#70543e',
            grassColor: '#394428',
            upgradeSize: 22.5
        };

        // Grass texture for background
        let grassTexture = null;
        let grassPattern = null;
        let grassOffsetX = 0;
        let grassOffsetY = 0;
        let grassScale = 1;

        // Tree images
        const treeImages = {
            tree1: null,
            tree2: null,
            tree3: null
        };

        let currentTreeFolder = 'forest-trees';

        // Patch images
        const patchImages = {
            patch1: null,
            patch2: null,
            patch3: null,
            patch4: null,
            patch5: null,
            patch6: null,
            patch7: null
        };

        // Upgrade images
        const upgradeImages = {
            SPEED: null,
            GASOLINE: null,
            ROTATION: null,
            AMMUNITION: null,
            KINETICS: null,
            HEALTH: null
        };

        // Load tree images
        function loadTreeImages() {
            const treeType = currentTreeFolder || 'forest-trees';
            const baseName = treeType === 'forest-snow-trees' ? 'forest-snow-tree' : 'forest-tree';
            const folder = `/assets/images/terrain/trees/${treeType}`;
            const treePaths = {
                tree1: `${folder}/${baseName}-1.png`,
                tree2: `${folder}/${baseName}-2.png`,
                tree3: `${folder}/${baseName}-3.png`
            };

            Object.entries(treePaths).forEach(([key, path]) => {
                const img = new Image();
                img.onload = function() {
                    treeImages[key] = img;
                    console.log('Loaded tree image:', key, 'Size:', img.width, 'x', img.height);
                };
                img.onerror = function() {
                    console.error('Failed to load tree image:', key, path);
                };
                img.src = path;
            });
        }

        // Load patch images
        function loadPatchImages() {
            console.log('🔄 Starting to load patch images...');
            const patchPaths = {
                patch1: '/assets/images/terrain/patches/patch-1.png',
                patch2: '/assets/images/terrain/patches/patch-2.png',
                patch3: '/assets/images/terrain/patches/patch-3.png',
                patch4: '/assets/images/terrain/patches/patch-4.png',
                patch5: '/assets/images/terrain/patches/patch-5.png',
                patch6: '/assets/images/terrain/patches/patch-6.png',
                patch7: '/assets/images/terrain/patches/patch-7.png'
            };

            Object.entries(patchPaths).forEach(([key, path]) => {
                const img = new Image();
                img.onload = function() {
                    patchImages[key] = img;
                    console.log('✅ Loaded patch image:', key, 'Size:', img.width, 'x', img.height);
                };
                img.onerror = function() {
                    console.error('❌ Failed to load patch image:', key, path);
                    patchImages[key] = null;
                };
                img.src = path;
                console.log('🔄 Loading patch image:', key, 'from:', path);
            });
        }

        // Load upgrade images
        function loadUpgradeImages() {
            const upgradePaths = {
                SPEED: '/assets/images/upgrades/speed-1.png',
                GASOLINE: '/assets/images/upgrades/gasoline-1.png',
                ROTATION: '/assets/images/upgrades/rotation-1.png',
                AMMUNITION: '/assets/images/upgrades/ammo-1.png',
                KINETICS: '/assets/images/upgrades/kinetics-1.png',
                HEALTH: '/assets/images/upgrades/health-1.png' // Will need to create this
            };

            Object.entries(upgradePaths).forEach(([key, path]) => {
                const img = new Image();
                img.onload = function() {
                    upgradeImages[key] = img;
                    console.log('Loaded upgrade image:', key, 'Size:', img.width, 'x', img.height);
                };
                img.onerror = function() {
                    console.error('Failed to load upgrade image:', key, path);
                    // Fallback will be handled in renderUpgrade function
                };
                img.src = path;
            });
        }

        // Load grass texture
        function loadGrassTexture() {
            const grassImg = new Image();
            grassImg.onload = function() {
                grassTexture = grassImg;
                console.log('Loaded grass texture:', grassImg.width, 'x', grassImg.height);
                
                // Create seamless pattern from grass texture
                const patternCanvas = document.createElement('canvas');
                const patternCtx = patternCanvas.getContext('2d');
                patternCanvas.width = grassImg.width;
                patternCanvas.height = grassImg.height;
                patternCtx.drawImage(grassImg, 0, 0);
                grassPattern = ctx.createPattern(patternCanvas, 'repeat');
                
                // Randomize grass texture position and scale once when loaded
                randomizeGrassTexture();
                
                // Force terrain cache recreation now that grass pattern is ready
                terrainRendered = false;
                console.log('🌱 Grass pattern loaded - terrain cache will be recreated');
            };
            grassImg.onerror = function() {
                console.error('Failed to load grass texture');
            };
            grassImg.src = '/assets/images/textures/terrain/grass-layer.png';
        }

        // Randomize grass texture position and scale (called once when terrain is built)
        function randomizeGrassTexture() {
            // Randomize position with larger range for more noticeable effect
            grassOffsetX = Math.random() * 200;
            grassOffsetY = Math.random() * 200;
            
            // Randomize scale by +/- 20%
            grassScale = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2 (80% to 120%)
            
            console.log('Grass texture randomized - offset:', grassOffsetX.toFixed(1), grassOffsetY.toFixed(1), 'scale:', grassScale.toFixed(2));
        }

        // Initialize tree images and upgrade images
        loadTreeImages();
        loadPatchImages();
        loadUpgradeImages();
        loadGrassTexture();





        // AI control panel functionality
        aiPlusBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            aiCount++;
            updateAIList();
            socket.emit('applyAISettings', { aiCount, aiLevel });
        });

        aiMinusBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            if (aiCount > 0) {
                aiCount--;
                updateAIList();
                socket.emit('applyAISettings', { aiCount, aiLevel });
            }
        });

        // AI level dropdown event listener
        aiLevelSelect.addEventListener('change', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            aiLevel = e.target.value;
            // Reset game with new AI level
            socket.emit('resetGameWithAILevel', { aiLevel });
        });

        function updateAIList() {
            aiList.innerHTML = '';
            
            if (!gameState.tanks || !gameState.players) return;
            
            const aiTanks = gameState.tanks.filter(tank => tank.id.startsWith('ai_'));
            
            aiTanks.forEach((tank, index) => {
                const player = gameState.players.find(p => p.id === tank.id);
                const aiEntry = document.createElement('div');
                aiEntry.className = 'ai-entry';
                
                // Calculate percentages
                const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
                const speedPercent = Math.max(0, Math.min(100, (tank.attributes.speed / 50) * 100));
                const gasolinePercent = Math.max(0, Math.min(100, tank.attributes.gasoline));
                const rotationPercent = Math.max(0, Math.min(100, (tank.attributes.rotation / 30) * 100));
                const kineticsPercent = Math.max(0, Math.min(100, (tank.attributes.kinetics / 300) * 100));
                
                // Helper function to get color for attribute percentage
                function getAttributeColor(percent) {
                    if (percent < 25) return '#F44336'; // Red when < 25%
                    if (percent < 50) return '#FFC107'; // Yellow when < 50%
                    return '#FFFFFF'; // White for normal
                }
                
                const healthColor = getAttributeColor(healthPercent);
                const speedColor = getAttributeColor(speedPercent);
                const gasolineColor = getAttributeColor(gasolinePercent);
                const rotationColor = getAttributeColor(rotationPercent);
                const kineticsColor = getAttributeColor(kineticsPercent);
                
                aiEntry.innerHTML = `
                    <div class="ai-entry-name">${player ? player.callname : `AI-${aiLevel.charAt(0).toUpperCase() + aiLevel.slice(1)} ${index + 1}`}</div>
                    <div class="ai-attribute-line">Health: <span style="color: ${healthColor};">${Math.round(healthPercent)}%</span></div>
                    <div class="ai-attribute-line">Speed: <span style="color: ${speedColor};">${Math.round(speedPercent)}%</span></div>
                    <div class="ai-attribute-line">Gasoline: <span style="color: ${gasolineColor};">${Math.round(gasolinePercent)}%</span></div>
                    <div class="ai-attribute-line">Rotation: <span style="color: ${rotationColor};">${Math.round(rotationPercent)}%</span></div>
                    <div class="ai-attribute-line">Kinetics: <span style="color: ${kineticsColor};">${Math.round(kineticsPercent)}%</span></div>
                    <div class="ai-attribute-line">Ammo: ${Math.round(tank.attributes.ammunition)}</div>
                `;
                aiList.appendChild(aiEntry);
            });
        }





        // Initialize AI list
        updateAIList();

        // AI Status Panel Management
        const aiStatusPanels = new Map();

        function createAIStatusPanel(aiId, tank, player) {
            const panel = document.createElement('div');
            panel.className = 'ai-status-panel';
            panel.id = `ai-status-${aiId}`;
            
            const level = aiLevel;
            
            panel.innerHTML = `
                <div class="ai-status-header">
                    <span class="ai-status-name">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px; color: #FF6B6B;">smart_toy</span>
                        ${player.callname}
                    </span>
                    <span class="ai-status-level">${level} - ${player.strategy || 'Unknown'}</span>
                </div>
                <div class="ai-status-grid">
                    <div class="ai-status-item">
                        <span class="ai-status-label">Health</span>
                        <span class="ai-status-value" id="ai-${aiId}-health">${Math.round(tank.attributes.health)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Rotation</span>
                        <span class="ai-status-value" id="ai-${aiId}-rotation">${Math.round(tank.attributes.rotation)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Speed</span>
                        <span class="ai-status-value" id="ai-${aiId}-speed">${Math.round(tank.attributes.speed)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Kinetics</span>
                        <span class="ai-status-value" id="ai-${aiId}-kinetics">${Math.round(tank.attributes.kinetics)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Gasoline</span>
                        <span class="ai-status-value" id="ai-${aiId}-gasoline">${Math.round(tank.attributes.gasoline)}%</span>
                    </div>
                    <div class="ai-status-item">
                        <span class="ai-status-label">Ammo</span>
                        <span class="ai-status-value" id="ai-${aiId}-ammo">${Math.round(tank.attributes.ammunition)}</span>
                    </div>
                </div>
            `;
            
            document.getElementById('aiStatusContainer').appendChild(panel);
            aiStatusPanels.set(aiId, panel);
            
            return panel;
        }

        function updateAIStatusPanel(aiId, tank) {
            const panel = aiStatusPanels.get(aiId);
            if (!panel) return;
            
            // Helper function to get color based on percentage
            function getColorForPercentage(percent) {
                if (percent >= 80) return '#00ff00'; // Green
                if (percent >= 60) return '#8BC34A'; // Light Green
                if (percent >= 30) return '#FFC107'; // Yellow (Low)
                if (percent >= 15) return '#FF9800'; // Orange
                return '#F44336'; // Red (Critical)
            }
            
            // Calculate percentages based on default attribute ranges
            const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
            const speedPercent = Math.max(0, Math.min(100, (tank.attributes.speed / 50) * 100));
            const gasolinePercent = Math.max(0, Math.min(100, tank.attributes.gasoline));
            const rotationPercent = Math.max(0, Math.min(100, (tank.attributes.rotation / 30) * 100));
            const kineticsPercent = Math.max(0, Math.min(100, (tank.attributes.kinetics / 300) * 100));
            
            // Update values with color coding
            const healthEl = panel.querySelector(`#ai-${aiId}-health`);
            const rotationEl = panel.querySelector(`#ai-${aiId}-rotation`);
            const speedEl = panel.querySelector(`#ai-${aiId}-speed`);
            const kineticsEl = panel.querySelector(`#ai-${aiId}-kinetics`);
            const gasolineEl = panel.querySelector(`#ai-${aiId}-gasoline`);
            const ammoEl = panel.querySelector(`#ai-${aiId}-ammo`);
            
            if (healthEl) {
                healthEl.textContent = Math.round(healthPercent) + '%';
                healthEl.style.color = getColorForPercentage(healthPercent);
            }
            if (rotationEl) {
                rotationEl.textContent = Math.round(rotationPercent) + '%';
                rotationEl.style.color = getColorForPercentage(rotationPercent);
            }
            if (speedEl) {
                speedEl.textContent = Math.round(speedPercent) + '%';
                speedEl.style.color = getColorForPercentage(speedPercent);
            }
            if (kineticsEl) {
                kineticsEl.textContent = Math.round(kineticsPercent) + '%';
                kineticsEl.style.color = getColorForPercentage(kineticsPercent);
            }
            if (gasolineEl) {
                gasolineEl.textContent = Math.round(gasolinePercent) + '%';
                gasolineEl.style.color = getColorForPercentage(gasolinePercent);
            }
            if (ammoEl) {
                ammoEl.textContent = Math.round(tank.attributes.ammunition);
                // Special color coding for ammo (critical when < 5, low when < 10)
                const ammoColor = tank.attributes.ammunition < 5 ? '#F44336' : 
                                 tank.attributes.ammunition < 10 ? '#FFC107' : '#00ff00';
                ammoEl.style.color = ammoColor;
            }
        }

        function removeAIStatusPanel(aiId) {
            const panel = aiStatusPanels.get(aiId);
            if (panel) {
                panel.remove();
                aiStatusPanels.delete(aiId);
            }
        }

        function updateAIStatusPanelPositions() {
            if (!gameState.tanks) return;
            
            const canvas = document.getElementById('gameCanvas');
            const canvasRect = canvas.getBoundingClientRect();
            
            // Get all AI tanks and sort them by ID for consistent positioning
            const aiTanks = gameState.tanks.filter(t => t.id.startsWith('ai_')).sort((a, b) => a.id.localeCompare(b.id));
            
            aiTanks.forEach((tank, index) => {
                const panel = aiStatusPanels.get(tank.id);
                if (!panel) return;
                
                // Convert tank position to screen coordinates
                const screenX = (tank.position.x / 1500) * canvasRect.width; // Use actual game width
                const screenY = (tank.position.y / 900) * canvasRect.height; // Use actual game height
                
                // Position panels side by side at the top of the screen
                const panelWidth = 200; // Approximate panel width
                const panelHeight = 80; // Approximate panel height
                const margin = 10;
                
                // Calculate horizontal position to avoid overlap
                const maxPanelsPerRow = Math.floor(canvasRect.width / (panelWidth + margin));
                const row = Math.floor(index / maxPanelsPerRow);
                const col = index % maxPanelsPerRow;
                
                const left = col * (panelWidth + margin) + margin;
                const top = row * (panelHeight + margin) + margin;
                
                panel.style.left = `${left}px`;
                panel.style.top = `${top}px`;
                panel.style.position = 'fixed'; // Use fixed positioning for consistent layout
            });
        }

        // Function to create AI status panels for existing AI tanks
        function createAIStatusPanelsForExistingTanks() {
            if (!gameState.tanks || !gameState.players) return;
            
            // Count existing AI tanks and sync with control panel
            const aiTanks = gameState.tanks.filter(tank => tank.id.startsWith('ai_'));
            aiCount = aiTanks.length;
            updateAIList();
            
            // AI status panel creation removed - no more red/black popups!
        }



        // Reset button functionality
        resetButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            // Removed reset button logging to clean up console
            socket.emit('resetGame');
            
            // Reset local state
            aiCount = 0;
            updateAIList();
            
            // AI status panel cleanup removed - no more red/black popups!
        });











        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('requestGameState');
        });

        // Handle terrain map changes
        socket.on('terrainMapChanged', (data) => {
            console.log('Terrain map changed:', data.mapName);
            forceTerrainRecreation();
        });



            socket.on('gameState', (data) => {
            // Removed logging to clean up console
            // Handle delta compression updates
            if (data.type === 'delta') {
                const newTreeFolder = data.treeParams?.treeType;
                if (newTreeFolder && newTreeFolder !== currentTreeFolder) {
                    currentTreeFolder = newTreeFolder;
                    loadTreeImages();
                }
                // Apply delta updates to existing game state
                if (data.tanks) {
                    // Update or add tanks
                    for (const tank of data.tanks) {
                        const existingIndex = gameState.tanks.findIndex(t => t.id === tank.id);
                        if (existingIndex >= 0) {
                            gameState.tanks[existingIndex] = tank;
                        } else {
                            gameState.tanks.push(tank);
                        }
                    }
                }
                
                if (data.shells) {
                    gameState.shells = data.shells;
                }
                
                if (data.upgrades) {
                    // Update or add upgrades
                    for (const upgrade of data.upgrades) {
                        const existingIndex = gameState.upgrades.findIndex(u => 
                            u.position.x === upgrade.position.x && u.position.y === upgrade.position.y);
                        if (existingIndex >= 0) {
                            gameState.upgrades[existingIndex] = upgrade;
                        } else {
                            gameState.upgrades.push(upgrade);
                        }
                    }
                }
                
                if (data.players) {
                    // Update or add players
                    for (const player of data.players) {
                        const existingIndex = gameState.players.findIndex(p => p.id === player.id);
                        if (existingIndex >= 0) {
                            gameState.players[existingIndex] = player;
                        } else {
                            gameState.players.push(player);
                        }
                    }
                }
                
                if (data.patches) {
                    gameState.patches = data.patches;
                    // Removed logging to clean up console
                    // Force terrain recreation when patches change
                    window.forceTerrainRecreate = true;
                    terrainRendered = false;
                }
                
                if (data.patchConfigs) {
                    gameState.patchConfigs = data.patchConfigs;
                    // Removed logging to clean up console
                    // Force terrain recreation when patch configs change
                    window.forceTerrainRecreate = true;
                    terrainRendered = false;
                }
            } else {
                // Full state update (fallback)
                if (data.type === 'full' && data.data) {
                    gameState = data.data;
                    const newTreeFolder = gameState.treeParams?.treeType;
                    if (newTreeFolder && newTreeFolder !== currentTreeFolder) {
                        currentTreeFolder = newTreeFolder;
                        loadTreeImages();
                    }
                } else {
                    gameState = data;
                    const newTreeFolder = gameState.treeParams?.treeType;
                    if (newTreeFolder && newTreeFolder !== currentTreeFolder) {
                        currentTreeFolder = newTreeFolder;
                        loadTreeImages();
                    }
                }
                
                // Force terrain recreation for full state updates
                if (gameState.patches && gameState.patches.length > 0) {
                    // Removed logging to clean up console
                    window.forceTerrainRecreate = true;
                    terrainRendered = false;
                }
            }
            
            // Debug: Log AI tank positions and distances
            if (gameState.tanks) {
                const aiTanks = gameState.tanks.filter(tank => tank.id.startsWith('ai_'));
                if (aiTanks.length >= 2) {
                    const tank1 = aiTanks[0];
                    const tank2 = aiTanks[1];
                    const distance = Math.sqrt(
                        Math.pow(tank1.position.x - tank2.position.x, 2) + 
                        Math.pow(tank1.position.y - tank2.position.y, 2)
                    );
                    // Removed AI distance debug logging to clean up console
                    
                    // Log if tanks are too close
                    if (distance < 200) {
                        // Removed tank proximity logging to clean up console
                    }
                }
            }
            
            // Update AI list with real-time data
            updateAIList();
        });



        socket.on('aiAdded', (data) => {
            // Removed AI event logging to clean up console
            aiTankId = data.aiId;
            
            // AI status panel creation removed - no more red/black popups!
        });

        socket.on('aiRemoved', (data) => {
            // Removed AI event logging to clean up console
            aiTankId = null;
            
            // AI status panel removal removed - no more red/black popups!
        });

        socket.on('gameReset', (data) => {
            // Removed game reset logging to clean up console
            
            // Update AI level dropdown if provided
            if (data.aiLevel) {
                aiLevel = data.aiLevel;
                aiLevelSelect.value = aiLevel;
            }
            
            // Reset AI count to 0 on game reset
            aiCount = 0;
            updateAIList();
            
            // Reset notification removed - no more annoying popup!
        });

        socket.on('settingsApplied', (data) => {
            // Removed settings logging to clean up console
            // Show a notification without forcing reconnection
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #4CAF50;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                z-index: 1000;
                font-family: Arial, sans-serif;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;
            notification.textContent = data.message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        });

        socket.on('forceReconnect', (data) => {
            // Removed force reconnect logging to clean up console
            // This event should now be rare and only used for critical updates
        });







        // Tank texture mapping - will be loaded from shared config
        let tankTextures = {};
        
        // Shell animation sprite
        let shellSprite = null;
        const shellSpriteImage = new Image();
        shellSpriteImage.onload = function() {
            shellSprite = this;
            console.log('Shell sprite loaded:', this.width, 'x', this.height);
        };
        shellSpriteImage.onerror = function() {
            console.error('Failed to load shell sprite');
        };
        shellSpriteImage.src = '/assets/images/shells/shell-animation.png?t=' + Date.now(); // Cache bust

        // Load tank textures from shared config
        tankTextures = tankCamos;
        
        // Preload tank textures
        const tankTextureImages = {};
        // Removed texture loading logging to clean up console
        Object.entries(tankTextures).forEach(([key, info]) => {
            const img = new Image();
            img.onload = function() {
                tankTextureImages[key] = img;
                // Removed texture loading logging to clean up console
            };
            img.onerror = function() {
                console.error('Failed to load texture:', key, info.texture);
            };
            img.src = `/assets/images/${info.texture}`;
        });

        // Tank images - simplified layered system
        let tankBodyContours = null;
        let tankBodyColorMap = null;
        let tankTurretContours = null;
        let tankTurretBaseColorMap = null;
        let tankTurretGunneryColorMap = null;

        // Load tank images
        function loadTankImages() {
            // Removed tank image loading logging to clean up console
            
            // Load contour images
            const tankBodyContoursImage = new Image();
            tankBodyContoursImage.onload = function() {
                tankBodyContours = this;
                // Removed tank image loading logging to clean up console
            };
            tankBodyContoursImage.onerror = function() {
                console.error('Failed to load tank body contours');
            };
            tankBodyContoursImage.src = '/assets/images/tanks/body_contours.png';

            const tankTurretContoursImage = new Image();
            tankTurretContoursImage.onload = function() {
                tankTurretContours = this;
                // Removed tank image loading logging to clean up console
            };
            tankTurretContoursImage.onerror = function() {
                console.error('Failed to load tank turret contours');
            };
            tankTurretContoursImage.src = '/assets/images/tanks/turret_contours.png';

            // Load color map images
            const tankBodyColorMapImage = new Image();
            tankBodyColorMapImage.onload = function() {
                tankBodyColorMap = this;
                // Removed tank image loading logging to clean up console
            };
            tankBodyColorMapImage.onerror = function() {
                console.error('Failed to load tank body color map');
            };
            tankBodyColorMapImage.src = '/assets/images/tanks/bodyBase_colourMap.png';

            const tankTurretBaseColorMapImage = new Image();
            tankTurretBaseColorMapImage.onload = function() {
                tankTurretBaseColorMap = this;
                // Removed tank image loading logging to clean up console
            };
            tankTurretBaseColorMapImage.onerror = function() {
                console.error('Failed to load tank turret base color map');
            };
            tankTurretBaseColorMapImage.src = '/assets/images/tanks/turretBase_colourMap.png';

            const tankTurretGunneryColorMapImage = new Image();
            tankTurretGunneryColorMapImage.onload = function() {
                tankTurretGunneryColorMap = this;
                // Removed tank image loading logging to clean up console
            };
            tankTurretGunneryColorMapImage.onerror = function() {
                console.error('Failed to load tank turret gunnery color map');
            };
            tankTurretGunneryColorMapImage.src = '/assets/images/tanks/turretGunnery_colourMap.png';
        }

        // Load tank images on startup
        loadTankImages();

        // Helper functions for tank rendering
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function getCamoPixel(x, y, pattern, scale) {
            if (!camoTextureData[pattern]) return 0;
            const data = camoTextureData[pattern];
            const scaledX = Math.floor(x * scale) % 256;
            const scaledY = Math.floor(y * scale) % 256;
            const index = (scaledY * 256 + scaledX) * 4;
            return data[index] / 255; // Return grayscale value
        }

        function applyCamoBlend(pixelR, pixelG, pixelB, camoValue, blendMode, opacity) {
            const camoR = camoValue * 255;
            const camoG = camoValue * 255;
            const camoB = camoValue * 255;
            
            let newR, newG, newB;
            
            switch (blendMode) {
                case 'overlay-pixel':
                    newR = pixelR < 128 ? (2 * pixelR * camoR) / 255 : 255 - (2 * (255 - pixelR) * (255 - camoR)) / 255;
                    newG = pixelG < 128 ? (2 * pixelG * camoG) / 255 : 255 - (2 * (255 - pixelG) * (255 - camoG)) / 255;
                    newB = pixelB < 128 ? (2 * pixelB * camoB) / 255 : 255 - (2 * (255 - pixelB) * (255 - camoB)) / 255;
                    break;
                default:
                    newR = pixelR;
                    newG = pixelG;
                    newB = pixelB;
            }
            
            // Apply opacity
            newR = pixelR + (newR - pixelR) * opacity;
            newG = pixelG + (newG - pixelG) * opacity;
            newB = pixelB + (newB - pixelB) * opacity;
            
            return [newR, newG, newB];
        }

        // Pre-process camo textures for performance
        const camoTextureData = {};
        Object.entries(tankTextures).forEach(([key, info]) => {
            if (info.texture) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 256;
                    ctx.drawImage(img, 0, 0, 256, 256);
                    camoTextureData[key] = ctx.getImageData(0, 0, 256, 256).data;
                };
                img.src = `/assets/images/${info.texture}`;
            }
        });

        // Render functions - Exact copy from tank.html
        function drawCamoLayer(image, centerX, centerY, scale, layerType = 'body') {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            // For camo layers, draw normally preserving transparency and blend mode
            ctx.drawImage(image, x, y, width, height);
        }

        // Generate cache key for tank sprite based on appearance factors
        function generateTankCacheKey(player, tank) {
            const playerColor = player ? player.tankColor : '#888888';
            const playerCamo = player ? (player.tankCamo || 'none') : 'none';
            const turretAngle = Math.round((tank.turretAngle || 0) * 10) / 10; // Round to 0.1 precision
            const bodyAngle = Math.round(tank.angle * 10) / 10;
            const recoilState = tank.isFiring ? `${tank.bodyRecoilOffset?.x || 0}_${tank.bodyRecoilOffset?.y || 0}` : 'normal';
            const turretRecoil = tank.isFiring ? `${tank.turretRecoilOffset?.x || 0}_${tank.turretRecoilOffset?.y || 0}` : 'normal';
            const health = Math.floor(tank.attributes.health / 10) * 10; // Round health to nearest 10
            
            return `${playerColor}_${playerCamo}_${turretAngle}_${bodyAngle}_${recoilState}_${turretRecoil}_${health}`;
        }
        
        // Create cached tank sprite
        function createTankSprite(player, tank) {
            const spriteCanvas = document.createElement('canvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            
            // Make canvas large enough for tank with shadows
            spriteCanvas.width = 100;  // Enough for tank + shadows
            spriteCanvas.height = 100;
            
            const centerX = 50; // Center of our sprite canvas
            const centerY = 50;
            const scale = 0.067;
            
            // Render all tank layers to the sprite canvas
            spriteCtx.save();
            spriteCtx.translate(centerX, centerY);
            spriteCtx.rotate(tank.angle);
            
            // 1. Body color map (with expensive pixel manipulation)
            drawTankLayerToSprite(spriteCtx, tankBodyColorMap, 0, 0, scale, true, 'body', player);
            
            // 2. Body camo (if available)
            if (player && player.tankCamo && player.tankCamo !== 'none') {
                const camoBaseImage = window.camoBaseImage || loadCamoImage(player.tankCamo, 'base');
                if (camoBaseImage) {
                    spriteCtx.save();
                    spriteCtx.globalAlpha = 0.8;
                    const currentColor = player.tankColor || '#888888';
                    const isLightColor = isColorLight(currentColor);
                    const autoBlendMode = isLightColor ? 'multiply' : 'soft-light';
                    spriteCtx.globalCompositeOperation = autoBlendMode;
                    drawCamoLayer(camoBaseImage, 0, 0, scale, 'body');
                    spriteCtx.restore();
                }
            }
            
            // 3. Body contours
            drawTankLayerToSprite(spriteCtx, tankBodyContours, 0, 0, scale, false, 'body', player);
            
            // 4. Turret base color map
            if (tankTurretBaseColorMap) {
                spriteCtx.save();
                spriteCtx.translate((tank.turretRecoilOffset?.x || 0), (tank.turretRecoilOffset?.y || 0));
                spriteCtx.rotate((tank.turretAngle || 0) + (tank.turretPendulumAngle || 0));
                drawTankLayerToSprite(spriteCtx, tankTurretBaseColorMap, 0, 0, scale, true, 'turret', player);
                spriteCtx.restore();
            }
            
            // 5. Turret camo
            if (player && player.tankCamo && player.tankCamo !== 'none') {
                const camoTurretImage = window.camoTurretImage || loadCamoImage(player.tankCamo, 'turret');
                if (camoTurretImage) {
                    spriteCtx.save();
                    spriteCtx.translate((tank.turretRecoilOffset?.x || 0), (tank.turretRecoilOffset?.y || 0));
                    spriteCtx.rotate((tank.turretAngle || 0) + (tank.turretPendulumAngle || 0));
                    spriteCtx.globalAlpha = 0.8;
                    const currentColor = player.tankColor || '#888888';
                    const isLightColor = isColorLight(currentColor);
                    const autoBlendMode = isLightColor ? 'multiply' : 'soft-light';
                    spriteCtx.globalCompositeOperation = autoBlendMode;
                    drawCamoLayer(camoTurretImage, 0, 0, scale, 'turret');
                    spriteCtx.restore();
                }
            }
            
            // 6. Turret gunnery color map
            if (tankTurretGunneryColorMap) {
                spriteCtx.save();
                spriteCtx.translate((tank.turretRecoilOffset?.x || 0), (tank.turretRecoilOffset?.y || 0));
                spriteCtx.rotate((tank.turretAngle || 0) + (tank.turretPendulumAngle || 0));
                drawTankLayerToSprite(spriteCtx, tankTurretGunneryColorMap, 0, 0, scale, true, 'turret', player);
                spriteCtx.restore();
            }
            
            // 7. Turret contours
            if (tankTurretContours) {
                spriteCtx.save();
                spriteCtx.translate((tank.turretRecoilOffset?.x || 0), (tank.turretRecoilOffset?.y || 0));
                spriteCtx.rotate((tank.turretAngle || 0) + (tank.turretPendulumAngle || 0));
                drawTankLayerToSprite(spriteCtx, tankTurretContours, 0, 0, scale, false, 'turret', player);
                spriteCtx.restore();
            }
            
            spriteCtx.restore();
            
            return spriteCanvas;
        }
        
        // Clean old cache entries to prevent memory bloat
        function cleanTankCache() {
            if (tankSpriteCache.size > maxCacheSize) {
                const entries = Array.from(tankSpriteCache.entries());
                entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
                
                // Remove oldest 20% of entries
                const toRemove = Math.ceil(entries.length * 0.2);
                for (let i = 0; i < toRemove; i++) {
                    tankSpriteCache.delete(entries[i][0]);
                }
            }
        }
        
        // Optimized tank layer drawing for sprite creation (same logic, different context)
        function drawTankLayerToSprite(spriteCtx, image, centerX, centerY, scale, isColorMap = false, layerType = 'body', player = null) {
            if (!image) return;

            const x = centerX - (image.width * scale) / 2;
            const y = centerY - (image.height * scale) / 2;
            const width = image.width * scale;
            const height = image.height * scale;

            if (isColorMap) {
                // Perform the expensive pixel manipulation (same as original)
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                
                tempCtx.drawImage(image, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;
                
                const hexColor = player ? player.tankColor : '#888888';
                const targetR = parseInt(hexColor.slice(1, 3), 16);
                const targetG = parseInt(hexColor.slice(3, 5), 16);
                const targetB = parseInt(hexColor.slice(5, 7), 16);
                
                // Pixel manipulation (same as original)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) {
                        const pixelR = data[i];
                        const pixelG = data[i + 1];
                        const pixelB = data[i + 2];
                        const pixelA = data[i + 3];
                        
                        let newR, newG, newB;
                        newR = targetR < 128 ? (2 * pixelR * targetR) / 255 : 255 - (2 * (255 - pixelR) * (255 - targetR)) / 255;
                        newG = targetG < 128 ? (2 * pixelG * targetG) / 255 : 255 - (2 * (255 - pixelG) * (255 - targetG)) / 255;
                        newB = targetB < 128 ? (2 * pixelB * targetB) / 255 : 255 - (2 * (255 - pixelB) * (255 - targetB)) / 255;
                        
                        data[i] = Math.max(0, Math.min(255, Math.round(newR)));
                        data[i + 1] = Math.max(0, Math.min(255, Math.round(newG)));
                        data[i + 2] = Math.max(0, Math.min(255, Math.round(newB)));
                        data[i + 3] = pixelA;
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                
                // Apply shadows to sprite (same as original)
                if (typeof applyContourAndAmbientShadows !== 'undefined' && typeof OBJECT_HEIGHTS !== 'undefined') {
                    applyContourAndAmbientShadows(spriteCtx, OBJECT_HEIGHTS.TANK);
                    spriteCtx.drawImage(tempCanvas, x, y, width, height);
                    applyAmbientShadowAfterContour(spriteCtx, OBJECT_HEIGHTS.TANK);
                    spriteCtx.drawImage(tempCanvas, x, y, width, height);
                } else if (typeof applyShadow !== 'undefined') {
                    applyShadow(spriteCtx, 'DEFAULT', OBJECT_HEIGHTS ? OBJECT_HEIGHTS.TANK : 1);
                    spriteCtx.drawImage(tempCanvas, x, y, width, height);
                }
                
                spriteCtx.globalCompositeOperation = 'source-over';
                spriteCtx.drawImage(tempCanvas, x, y, width, height);
                
            } else {
                // For contours, draw normally
                spriteCtx.globalCompositeOperation = 'source-over';
                spriteCtx.drawImage(image, x, y, width, height);
            }
            
            // Reset sprite context
            if (typeof resetShadows !== 'undefined') {
                resetShadows(spriteCtx);
            } else {
                spriteCtx.shadowColor = 'transparent';
                spriteCtx.shadowBlur = 0;
                spriteCtx.shadowOffsetX = 0;
                spriteCtx.shadowOffsetY = 0;
                spriteCtx.globalAlpha = 1.0;
                spriteCtx.globalCompositeOperation = 'source-over';
            }
            
            spriteCtx.globalCompositeOperation = 'source-over';
        }

        function drawTankLayer(image, centerX, centerY, scale, isColorMap = false, layerType = 'body', player = null) {
            const height = image.height * scale;

            if (isColorMap) {
                // For color maps, apply pixel-level color manipulation
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                
                // Draw the original image
                tempCtx.drawImage(image, 0, 0);
                
                // Get image data for manipulation
                const imageData = tempCtx.getImageData(0, 0, image.width, image.height);
                const data = imageData.data;
                
                // Convert hex color to RGB and HSL
                const hexColor = player ? player.tankColor : '#888888';
                const targetR = parseInt(hexColor.slice(1, 3), 16);
                const targetG = parseInt(hexColor.slice(3, 5), 16);
                const targetB = parseInt(hexColor.slice(5, 7), 16);
                const targetHsl = rgbToHsl(targetR, targetG, targetB);
                
                // Apply pixel-level color manipulation (hard-light-pixel as default)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // If pixel is not transparent
                        const pixelR = data[i];
                        const pixelG = data[i + 1];
                        const pixelB = data[i + 2];
                        const pixelA = data[i + 3];
                        
                        // Apply hard-light-pixel blending
                        let newR, newG, newB;
                        newR = targetR < 128 ? (2 * pixelR * targetR) / 255 : 255 - (2 * (255 - pixelR) * (255 - targetR)) / 255;
                        newG = targetG < 128 ? (2 * pixelG * targetG) / 255 : 255 - (2 * (255 - pixelG) * (255 - targetG)) / 255;
                        newB = targetB < 128 ? (2 * pixelB * targetB) / 255 : 255 - (2 * (255 - pixelB) * (255 - targetB)) / 255;
                        
                        data[i] = Math.max(0, Math.min(255, Math.round(newR)));
                        data[i + 1] = Math.max(0, Math.min(255, Math.round(newG)));
                        data[i + 2] = Math.max(0, Math.min(255, Math.round(newB)));
                        data[i + 3] = pixelA; // Keep original alpha
                    }
                }
                
                // Put the modified image data back
                tempCtx.putImageData(imageData, 0, 0);
                
                // Apply dual shadows using the new shadow system (FOR COLOR MAPS)
                if (typeof applyContourAndAmbientShadows !== 'undefined' && typeof OBJECT_HEIGHTS !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx, OBJECT_HEIGHTS.TANK);
                    ctx.drawImage(tempCanvas, x, y, width, height);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx, OBJECT_HEIGHTS.TANK);
                    ctx.drawImage(tempCanvas, x, y, width, height);
                } else if (typeof applyShadow !== 'undefined') {
                    // Fallback to legacy shadow if new system not available
                    applyShadow(ctx, 'DEFAULT', OBJECT_HEIGHTS ? OBJECT_HEIGHTS.TANK : 1);
                    ctx.drawImage(tempCanvas, x, y, width, height);
                }
                
                // Draw the modified image (shadows are already drawn above)
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(tempCanvas, x, y, width, height);
                
            } else {
                // For contours, draw normally preserving transparency (NO SHADOWS)
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(image, x, y, width, height);
            }
            
            // Reset shadow settings after drawing
            if (typeof resetShadows !== 'undefined') {
                resetShadows(ctx);
            } else {
                // Fallback reset
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.globalAlpha = 1.0;
                ctx.globalCompositeOperation = 'source-over';
            }
            
            // Ensure we're back to source-over for the next layer
            ctx.globalCompositeOperation = 'source-over';
        }

        // Helper functions for color conversion (exact copy from tank.html)
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return [h, s, l];
        }
        
        function hslToRgb(h, s, l) {
            let r, g, b;
            
            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            return [
                Math.round(r * 255),
                Math.round(g * 255),
                Math.round(b * 255)
            ];
        }

        // Helper function to determine if a color is light (exact copy from tank.html)
        function isColorLight(hexColor) {
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.4; // Threshold for light colors
        }

        // Helper function to load camo images
        function loadCamoImage(camoType, layerType) {
            const image = new Image();
            image.src = `/assets/images/textures/camo/${layerType}_${camoType}.png`;
            
            // Store in window for reuse
            if (layerType === 'base') {
                window.camoBaseImage = image;
            } else if (layerType === 'turret') {
                window.camoTurretImage = image;
            }
            
            return image;
        }

        function renderTank(tank, player) {
            if (!tank.isAlive) return;

            // Check if tank images are loaded
            if (!tankBodyContours || !tankBodyColorMap) {
                // Fallback to simple rendering if images aren't loaded
                ctx.save();
                ctx.translate(tank.position.x, tank.position.y);
                ctx.rotate(tank.angle);
                
                let tankColor = '#888888'; // Default gray for AI
                if (player) {
                    tankColor = player.tankColor;
                } else if (tank.isAI) {
                    tankColor = '#888888'; // Specific gray for AI tanks
                }
                
                ctx.fillStyle = tankColor;
                ctx.fillRect(-10, -10, 20, 20);
                
                // Tank barrel
                ctx.fillStyle = '#333333';
                ctx.fillRect(0, -2, 15, 4);
                
                ctx.restore();
                return;
            }

            // OPTIMIZED: Use cached tank sprite instead of complex per-frame rendering
            const cacheKey = generateTankCacheKey(player, tank);
            let cachedSprite = tankSpriteCache.get(cacheKey);
            
            if (cachedSprite) {
                // Cache hit! Use existing sprite
                cachedSprite.lastUsed = Date.now();
                cacheHitCount++;
            } else {
                // Cache miss - create new sprite
                const spriteCanvas = createTankSprite(player, tank);
                cachedSprite = {
                    canvas: spriteCanvas,
                    lastUsed: Date.now()
                };
                tankSpriteCache.set(cacheKey, cachedSprite);
                cacheMissCount++;
                
                // Clean cache if needed
                cleanTankCache();
                
                // Log cache performance every 100 misses
                if (cacheMissCount % 100 === 0) {
                    const hitRate = (cacheHitCount / (cacheHitCount + cacheMissCount) * 100).toFixed(1);
                    // Removed tank sprite cache logging to clean up console
                }
            }
            
            // Log shell cache performance every 500 renders
            if (shellRenderCount % 500 === 0 && shellRenderCount > 0) {
                const shellHitRate = (shellCacheHits / shellRenderCount * 100).toFixed(1);
                // Removed shell cache logging to clean up console
            }
            
            // Draw the cached sprite (SUPER FAST!)
            ctx.save();
            ctx.translate(tank.position.x, tank.position.y);
            // 10% bigger tank sprite
            ctx.drawImage(cachedSprite.canvas, -55, -55, 110, 110); // Center and scale
            ctx.restore();

            // Draw shooting animation (fire flash) - matching tank designer
            if (tank.isFiring && tank.fireAnimation < 10) {
                ctx.save();
                ctx.translate(tank.position.x + (tank.bodyRecoilOffset?.x || 0), tank.position.y + (tank.bodyRecoilOffset?.y || 0));
                ctx.rotate(tank.angle);
                
                // Draw fire flash (matching tank designer)
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(20, 0, 3 + tank.fireAnimation, 0, Math.PI * 2); // Position at barrel tip
                ctx.fill();
                
                ctx.restore();
            }

            // Draw name, health bar, and team (not rotated) - moved higher to be above trees
            ctx.save();
            ctx.translate(tank.position.x, tank.position.y - 50);

            if (player) {
                // Player name (above)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(player.callname, 0, -5);

                // Health bar background (underneath) - moved closer to name
                ctx.fillStyle = '#1b1b1b';
                ctx.fillRect(-20, 2, 40, 6);

                // Health bar
                const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
                ctx.fillStyle = healthPercent > 50 ? '#4CAF50' : healthPercent > 25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, 2, (healthPercent / 100) * 40, 6);
            } else if (tank.isAI) {
                // AI tank - show name with (AI) suffix
                ctx.fillStyle = '#FF6B6B';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                
                // Find the player data for this AI tank
                const aiPlayer = gameState.players ? gameState.players.find(p => p.id === tank.id) : null;
                const displayName = aiPlayer ? aiPlayer.callname : 'AI';
                
                // Draw name with (AI) suffix instead of [AI] prefix
                ctx.fillText(displayName + ' (AI)', 0, -5);

                // Health bar background (underneath) - moved closer to name
                ctx.fillStyle = '#1b1b1b';
                ctx.fillRect(-20, 2, 40, 6);

                // Health bar
                const healthPercent = Math.max(0, Math.min(100, tank.attributes.health));
                ctx.fillStyle = healthPercent > 50 ? '#4CAF50' : healthPercent > 25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, 2, (healthPercent / 100) * 40, 6);
            }

            ctx.restore();
        }

        // Pre-cached trail gradients for common trail directions
        function getTrailGradient(trailStartX, trailStartY) {
            const key = `${Math.round(trailStartX)}_${Math.round(trailStartY)}`;
            let gradient = trailGradientCache.get(key);
            
            if (!gradient) {
                gradient = ctx.createLinearGradient(trailStartX, trailStartY, 0, 0);
                gradient.addColorStop(0, 'rgba(104, 105, 82, 0)');
                gradient.addColorStop(1, 'rgba(104, 105, 82, 0.8)');
                trailGradientCache.set(key, gradient);
                
                // Clean cache if it gets too big
                if (trailGradientCache.size > 100) {
                    const entries = Array.from(trailGradientCache.entries());
                    // Remove oldest 30% of entries
                    for (let i = 0; i < Math.floor(entries.length * 0.3); i++) {
                        trailGradientCache.delete(entries[i][0]);
                    }
                }
            }
            
            return gradient;
        }
        
        // Create cached shell sprite at specific rotation
        function createCachedShellSprite(angle, velocityMagnitude) {
            const spriteCanvas = document.createElement('canvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            
            // Make canvas big enough for rotated shell
            spriteCanvas.width = 30;
            spriteCanvas.height = 30;
            
            spriteCtx.save();
            spriteCtx.translate(15, 15); // Center
            spriteCtx.rotate(angle);
            
            if (shellSprite) {
                // Use optimized animation frame calculation
                const frameCount = 6;
                const frameHeight = 50;
                const animationSpeed = Math.min(velocityMagnitude / 50, 2);
                const currentFrame = Math.floor(animationTime * animationSpeed) % frameCount;
                
                spriteCtx.drawImage(
                    shellSprite,
                    0, currentFrame * frameHeight, 50, frameHeight,
                    -5.5, -5.5, 11, 11
                );
            } else {
                // Cached geometric fallback
                drawGeometricShell(spriteCtx);
            }
            
            spriteCtx.restore();
            return spriteCanvas;
        }
        
        // Optimized geometric shell drawing
        function drawGeometricShell(spriteCtx) {
            const shellLength = 8;
            const shellWidth = 3;
            const tipLength = 3;
            const backLength = 2;
            
            // Draw shell body (simplified)
            spriteCtx.fillStyle = '#797a62';
            spriteCtx.fillRect(-shellLength/2 + backLength, -shellWidth/2, shellLength - tipLength - backLength, shellWidth);
            
            // Draw shell tip (simplified)
            spriteCtx.fillStyle = '#5e5e58';
            spriteCtx.beginPath();
            spriteCtx.moveTo(shellLength/2, 0);
            spriteCtx.lineTo(shellLength/2 - tipLength, -shellWidth/2);
            spriteCtx.lineTo(shellLength/2 - tipLength, shellWidth/2);
            spriteCtx.closePath();
            spriteCtx.fill();
            
            // Draw shell back (simplified)
            spriteCtx.fillStyle = '#8b6914';
            spriteCtx.fillRect(-shellLength/2, -shellWidth/2, backLength, shellWidth);
        }
        
        // Clean shell sprite cache
        function cleanShellCache() {
            if (shellSpriteCache.size > maxShellCacheSize) {
                const entries = Array.from(shellSpriteCache.entries());
                entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);
                
                const toRemove = Math.ceil(entries.length * 0.3);
                for (let i = 0; i < toRemove; i++) {
                    shellSpriteCache.delete(entries[i][0]);
                }
            }
        }

        function renderShell(shell) {
            shellRenderCount++;
            
            // Pre-calculate expensive operations once
            const velocityMagnitude = Math.sqrt(shell.velocity.x * shell.velocity.x + shell.velocity.y * shell.velocity.y);
            
            if (velocityMagnitude < 0.1) return; // Skip nearly stationary shells (use small threshold instead of exact zero)
            
            const shellAngle = Math.atan2(shell.velocity.y, shell.velocity.x);
            
            // Cache key for shell sprite (round angle to reduce cache size)
            const roundedAngle = Math.round(shellAngle * 20) / 20; // Round to 0.05 radian precision
            const velocityClass = Math.round(velocityMagnitude / 25) * 25; // Group by velocity ranges
            const cacheKey = `${roundedAngle}_${velocityClass}`;
            
            let cachedShell = shellSpriteCache.get(cacheKey);
            
            if (cachedShell) {
                cachedShell.lastUsed = Date.now();
                shellCacheHits++;
            } else {
                const shellCanvas = createCachedShellSprite(roundedAngle, velocityMagnitude);
                cachedShell = {
                    canvas: shellCanvas,
                    lastUsed: Date.now()
                };
                shellSpriteCache.set(cacheKey, cachedShell);
                cleanShellCache();
            }
            
            ctx.save();
            ctx.translate(shell.position.x, shell.position.y);

            // Optimized trail rendering
            if (velocityMagnitude > 5) { // Only draw trails for fast-moving shells
                const trailLength = 13;
                const trailStartX = -shell.velocity.x * trailLength / velocityMagnitude;
                const trailStartY = -shell.velocity.y * trailLength / velocityMagnitude;
                
                const gradient = getTrailGradient(trailStartX, trailStartY);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(trailStartX, trailStartY);
                ctx.lineTo(0, 0);
                ctx.stroke();
            }

            // Draw ground shadow like upgrades/trees (height = 1)
            const drawX = -17.25, drawY = -17.25, drawW = 34.5, drawH = 34.5;
            ctx.save();
            if (typeof applyContourAndAmbientShadows !== 'undefined') {
                applyContourAndAmbientShadows(ctx, 2);
                ctx.drawImage(cachedShell.canvas, drawX, drawY, drawW, drawH);
                applyAmbientShadowAfterContour(ctx, 2);
                ctx.drawImage(cachedShell.canvas, drawX, drawY, drawW, drawH);
            } else if (typeof SHADOW_CONFIG !== 'undefined') {
                applyShadow(ctx, 'DEFAULT', 2);
                ctx.drawImage(cachedShell.canvas, drawX, drawY, drawW, drawH);
            } else {
                // Fallback simple shadow
                ctx.globalAlpha = 0.5;
                ctx.globalCompositeOperation = 'multiply';
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;
                ctx.drawImage(cachedShell.canvas, drawX, drawY, drawW, drawH);
            }
            ctx.restore();

            // Draw the shell itself (no shadow state)
            ctx.drawImage(cachedShell.canvas, drawX, drawY, drawW, drawH);

            ctx.restore();
        }



        function renderUpgrade(upgrade) {
            if (upgrade.collected) return;

            ctx.save();
            ctx.translate(upgrade.position.x, upgrade.position.y);
            
            // Apply random rotation if available
            if (upgrade.rotation !== undefined) {
                ctx.rotate(upgrade.rotation);
            }

            const upgradeImage = upgradeImages[upgrade.type];
            const size = terrainDefaults.upgradeSize;

            if (upgradeImage) {
                // Calculate image size with proper aspect ratio
                const imageAspectRatio = upgradeImage.width / upgradeImage.height;
                const scaledWidth = size;
                const scaledHeight = size / imageAspectRatio;
                
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx, OBJECT_HEIGHTS.UPGRADE);
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx, OBJECT_HEIGHTS.UPGRADE);
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT', OBJECT_HEIGHTS.UPGRADE);
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                }
                ctx.restore();
                
                // Draw the main upgrade image
                ctx.drawImage(upgradeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
            } else {
                // Fallback to original style if image not loaded
                // Enhanced fallback with new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx, OBJECT_HEIGHTS.UPGRADE);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx, OBJECT_HEIGHTS.UPGRADE);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT', OBJECT_HEIGHTS.UPGRADE);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                } else {
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillRect(-size/2, -size/2, size, size);
                }
                ctx.restore();
                
                // Main upgrade background
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(-size/2, -size/2, size, size);

                // Upgrade symbol
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(upgrade.type.charAt(0), 0, 0);
            }

            ctx.restore();
        }

        function renderTree(tree) {
            ctx.save();
            ctx.translate(tree.position.x, tree.position.y);

            // Apply swing animation with static random rotation offset
            // Tree trunk circle (1/6th of tree size) - centered in tree and rendered behind leaves in black
            ctx.save();
            ctx.fillStyle = 'black'; // Black trunk
            ctx.beginPath();
            ctx.arc(0, -tree.size/2, tree.size / 6, 0, Math.PI * 2); // Centered in the leaves circle
            ctx.fill();
            ctx.restore();
            
            ctx.save();
            ctx.translate(0, -tree.size/2); // Move to foliage center
            ctx.translate(tree.foliageOffsetX || 0, tree.foliageOffsetY || 0); // Apply translation offset
            ctx.rotate(tree.leafRotation); // Apply static random rotation first
            ctx.rotate(tree.swingAngle || 0); // Then apply dynamic swing animation
            
            // Tree foliage using actual tree images
            // Tree type and rotation are now initialized on the server side
            const treeImage = treeImages[tree.treeType];
            
            if (treeImage) {
                // Calculate image size based on tree size
                const imageSize = tree.size;
                const imageAspectRatio = treeImage.width / treeImage.height;
                const scaledWidth = imageSize;
                const scaledHeight = imageSize / imageAspectRatio;
                
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx, OBJECT_HEIGHTS.TREE);
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx, OBJECT_HEIGHTS.TREE);
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT', OBJECT_HEIGHTS.TREE);
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                }
                ctx.restore();
                
                // Draw the main tree image
                ctx.drawImage(treeImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
            } else {
                // Fallback to simple circle if image not loaded
                // Draw shadow first using new dual-shadow system
                ctx.save();
                if (typeof applyContourAndAmbientShadows !== 'undefined') {
                    // Apply contour shadow and draw shadow version
                    applyContourAndAmbientShadows(ctx, OBJECT_HEIGHTS.TREE);
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Apply ambient shadow and draw shadow version
                    applyAmbientShadowAfterContour(ctx, OBJECT_HEIGHTS.TREE);
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (typeof SHADOW_CONFIG !== 'undefined') {
                    applyShadow(ctx, 'DEFAULT', OBJECT_HEIGHTS.TREE);
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Fallback if shadow config not loaded
                    ctx.globalAlpha = 0.5;
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;
                    ctx.fillStyle = '#5e6936';
                    ctx.beginPath();
                    ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                
                // Draw main foliage
                ctx.fillStyle = '#5e6936';
                ctx.beginPath();
                ctx.arc(0, 0, tree.size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore(); // Restore foliage transform

            ctx.restore();
        }



        // REMOVED: Old terrain rendering function - terrain is now cached for massive performance boost!

        // Terrain cache functionality

        // Create cached terrain background
        function createTerrainCache() {
            if (terrainRendered && !window.forceTerrainRecreate) return;
            
            // Create off-screen canvas for terrain
            terrainCanvas = document.createElement('canvas');
            terrainCanvas.width = canvas.width;
            terrainCanvas.height = canvas.height;
            terrainCtx = terrainCanvas.getContext('2d');
            
            // Render terrain background FIRST
            terrainCtx.fillStyle = terrainDefaults.mudColor;
            terrainCtx.fillRect(0, 0, terrainCanvas.width, terrainCanvas.height);
            
            // Render patches AFTER the background (so they appear above it)
            if (gameState.patches && Array.isArray(gameState.patches)) {
                // Removed logging to clean up console
                gameState.patches.forEach((patch, index) => {
                    const patchImage = patchImages[patch.type];
                    if (patchImage) {
                        terrainCtx.save();
                        terrainCtx.translate(patch.position.x, patch.position.y);
                        terrainCtx.rotate(patch.rotation);
                        
                        // Calculate image size based on patch size
                        const imageSize = patch.size;
                        const imageAspectRatio = patchImage.width / patchImage.height;
                        const scaledWidth = imageSize;
                        const scaledHeight = imageSize / imageAspectRatio;
                        
                        // Get patch configuration from game state
                        const patchConfig = gameState.patchConfigs ? gameState.patchConfigs[patch.type] : null;
                        const blendMode = patchConfig ? patchConfig.blend : 'multiply';
                        const opacity = patchConfig ? patchConfig.opacity : 0.7;
                        
                        // Removed patch logging to clean up console
                        
                        // Draw patch with proper blending and opacity
                        terrainCtx.globalCompositeOperation = blendMode;
                        terrainCtx.globalAlpha = opacity;
                        terrainCtx.drawImage(patchImage, -scaledWidth/2, -scaledHeight/2, scaledWidth, scaledHeight);
                        terrainCtx.restore();
                    } else {
                        // Removed patch error logging to clean up console
                    }
                });
            } else {
                // Removed patch error logging to clean up console
            }
            
            if (grassPattern) {
                terrainCtx.save();
                terrainCtx.globalCompositeOperation = 'multiply';
                terrainCtx.globalAlpha = 0.5;
                terrainCtx.fillStyle = grassPattern;
                terrainCtx.scale(grassScale, grassScale);
                terrainCtx.fillRect(-grassOffsetX, -grassOffsetY, terrainCanvas.width + 400, terrainCanvas.height + 400);
                terrainCtx.restore();
            }
            
            terrainRendered = true;
            window.forceTerrainRecreate = false;
        }

        // Main render loop
        function render() {
            // Update shared animation timer (instead of Date.now() calls everywhere)
            animationTime = performance.now() * 0.001; // Convert to seconds
            
            // Create terrain cache on first run
            if (!terrainRendered) {
                createTerrainCache();
            }
            
            // Clear canvas and draw cached terrain (super fast!)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(terrainCanvas, 0, 0);

            // Render upgrades (background layer)
            if (gameState.upgrades && Array.isArray(gameState.upgrades)) {
                gameState.upgrades.forEach(renderUpgrade);
            }



                    // Render shells
        if (gameState.shells && Array.isArray(gameState.shells)) {
            gameState.shells.forEach(renderShell);
        }

                    // Render tanks
        if (gameState.tanks && Array.isArray(gameState.tanks)) {
            // Create a map of players for O(1) lookup instead of O(n) find
            const playerMap = new Map();
            if (gameState.players && Array.isArray(gameState.players)) {
                gameState.players.forEach(player => playerMap.set(player.id, player));
            }
            
            gameState.tanks.forEach(tank => {
                const player = playerMap.get(tank.id) || null;
                renderTank(tank, player);
            });
        }

            // Render trees (foreground layer - above tanks)
            if (gameState.trees && Array.isArray(gameState.trees)) {
                gameState.trees.forEach(renderTree);
            }

            requestAnimationFrame(render);
        }

        // Force terrain recreation when patches change
        function forceTerrainRecreation() {
            terrainRendered = false;
            window.forceTerrainRecreate = true;
        }

        // Start rendering
        render();
    </script>

    <!-- FPS Counter -->
    <div class="fps-counter" id="fpsCounter">
        <div class="fps-label">FPS</div>
        <div class="fps-value" id="fpsValue">60</div>
    </div>

    <!-- Performance Popup Overlay -->
    <div class="popup-overlay" id="popupOverlay"></div>

    <!-- Performance Popup -->
    <div class="performance-popup" id="performancePopup">
        <button class="close-popup" id="closePopup">&times;</button>
        <h3>Performance Monitor</h3>
        <div id="performanceContent">
            <!-- Performance items will be dynamically generated here -->
        </div>
    </div>

    <script>
        // FPS Counter and Performance Monitoring
        let fpsCounter = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let fpsHistory = [];
        const maxFpsHistory = 60;
        let fpsUpdateCounter = 0;
        const fpsUpdateInterval = 10; // Update FPS display every 10 frames (roughly 6 times per second at 60fps)
        
        // Cache DOM elements for performance
        const fpsElement = document.getElementById('fpsCounter');
        const fpsValueElement = document.getElementById('fpsValue');

        // Performance monitoring
        let performanceData = {
            fps: { current: 0, average: 0, min: 0, max: 0 },
            memory: { used: 0, total: 0, percentage: 0 },
            renderTime: { current: 0, average: 0 },
            gameObjects: { tanks: 0, shells: 0, trees: 0, upgrades: 0 },
            network: { latency: 0, packetsPerSecond: 0 }
        };

        // FPS Counter Update
        function updateFPS() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            
            if (deltaTime > 0) {
                const currentFPS = 1000 / deltaTime;
                fpsHistory.push(currentFPS);
                
                if (fpsHistory.length > maxFpsHistory) {
                    fpsHistory.shift();
                }
                
                const averageFPS = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
                const minFPS = Math.min(...fpsHistory);
                const maxFPS = Math.max(...fpsHistory);
                
                performanceData.fps = {
                    current: Math.round(currentFPS),
                    average: Math.round(averageFPS),
                    min: Math.round(minFPS),
                    max: Math.round(maxFPS)
                };
                
                // Only update display every few frames to reduce jitter
                fpsUpdateCounter++;
                if (fpsUpdateCounter >= fpsUpdateInterval) {
                    // Use a smoother average for display
                    const recentFPS = fpsHistory.slice(-10); // Last 10 frames
                    const displayFPS = Math.round(recentFPS.reduce((a, b) => a + b, 0) / recentFPS.length);
                    
                    // Update FPS counter display
                    fpsValueElement.textContent = displayFPS;
                    
                    // Color coding based on FPS
                    fpsValueElement.classList.remove('low', 'medium');
                    if (displayFPS < 30) {
                        fpsValueElement.classList.add('low');
                    } else if (displayFPS < 50) {
                        fpsValueElement.classList.add('medium');
                    }
                    
                    fpsUpdateCounter = 0; // Reset counter
                }
                
                // Auto-enable performance mode if FPS is critically low
                // DISABLED: This was overriding the zoom. User wants to maintain zoom regardless of FPS.
                /*
                if (performanceData.fps.current < 15 && !performanceMode && fpsHistory.length > 10) {
                    // Removed performance mode logging to clean up console
                    performanceMode = true;
                    
                    const ultraMaxWidth = 1200;
                    const ultraMaxHeight = 800;
                    
                    canvas.width = ultraMaxWidth * (window.devicePixelRatio || 1);
                    canvas.height = ultraMaxHeight * (window.devicePixelRatio || 1);
                    
                    // Calculate reduced zoom for auto-performance mode
                    const screenWidth = window.innerWidth - 40;
                    const screenHeight = window.innerHeight - 100;
                    const scaleX = screenWidth / ultraMaxWidth;
                    const scaleY = screenHeight / ultraMaxHeight;
                    const zoomFactor = Math.min(scaleX, scaleY, 1.5); // Reduced zoom cap for performance
                    
                    canvas.style.width = (ultraMaxWidth * zoomFactor) + 'px';
                    canvas.style.height = (ultraMaxHeight * zoomFactor) + 'px';
                    
                    fpsElement.style.color = '#ff6600';
                    fpsElement.textContent = `FPS: ${performanceData.fps.current} (AUTO PERF)`;
                }
                */
            }
            
            lastTime = currentTime;
            requestAnimationFrame(updateFPS);
        }

        // Performance Monitoring
        function updatePerformanceData() {
            // Memory usage (if available)
            if (performance.memory) {
                const memory = performance.memory;
                performanceData.memory = {
                    used: Math.round(memory.usedJSHeapSize / 1024 / 1024),
                    total: Math.round(memory.totalJSHeapSize / 1024 / 1024),
                    percentage: Math.round((memory.usedJSHeapSize / memory.totalJSHeapSize) * 100)
                };
            }

            // Game objects count
            if (gameState) {
                performanceData.gameObjects = {
                    tanks: gameState.tanks ? gameState.tanks.length : 0,
                    shells: gameState.shells ? gameState.shells.length : 0,
                    trees: gameState.trees ? gameState.trees.length : 0,
                    upgrades: gameState.upgrades ? gameState.upgrades.length : 0
                };
            }

            // Network latency (if socket is available)
            if (socket && socket.connected) {
                const startTime = performance.now();
                socket.emit('ping', () => {
                    const latency = performance.now() - startTime;
                    performanceData.network.latency = Math.round(latency);
                });
            }

            // Update every second
            setTimeout(updatePerformanceData, 1000);
        }

        // Generate performance report
        function generatePerformanceReport() {
            const content = document.getElementById('performanceContent');
            content.innerHTML = '';

            // FPS Section
            addPerformanceItem(content, 'Current FPS', `${performanceData.fps.current}`, performanceData.fps.current, 60);
            addPerformanceItem(content, 'Average FPS', `${performanceData.fps.average}`, performanceData.fps.average, 60);
            addPerformanceItem(content, 'Min FPS', `${performanceData.fps.min}`, performanceData.fps.min, 60);
            addPerformanceItem(content, 'Max FPS', `${performanceData.fps.max}`, performanceData.fps.max, 60);

            // Memory Section
            if (performanceData.memory.used > 0) {
                addPerformanceItem(content, 'Memory Used', `${performanceData.memory.used} MB`, performanceData.memory.percentage, 100);
                addPerformanceItem(content, 'Memory Total', `${performanceData.memory.total} MB`, 100, 100);
            }

            // Game Objects Section
            addPerformanceItem(content, 'Tanks', `${performanceData.gameObjects.tanks}`, performanceData.gameObjects.tanks, 50);
            addPerformanceItem(content, 'Shells', `${performanceData.gameObjects.shells}`, performanceData.gameObjects.shells, 100);
            addPerformanceItem(content, 'Trees', `${performanceData.gameObjects.trees}`, performanceData.gameObjects.trees, 200);
            addPerformanceItem(content, 'Upgrades', `${performanceData.gameObjects.upgrades}`, performanceData.gameObjects.upgrades, 50);

            // Network Section
            if (performanceData.network.latency > 0) {
                addPerformanceItem(content, 'Network Latency', `${performanceData.network.latency}ms`, performanceData.network.latency, 100);
            }

            // System Info
            addPerformanceItem(content, 'Screen Resolution', `${window.screen.width}x${window.screen.height}`, 100, 100);
            addPerformanceItem(content, 'Canvas Size', `${canvas.width}x${canvas.height}`, 100, 100);
            
            // Canvas optimization info
            const canvasPixels = canvas.width * canvas.height;
            const maxRecommended = 1500 * 900; // 1.35M pixels for game arena
            addPerformanceItem(content, 'Canvas Pixels', `${(canvasPixels / 1000000).toFixed(1)}M`, canvasPixels, maxRecommended);
            
            // Zoom info
            const zoomFactor = parseFloat(canvas.style.width) / 1500;
            addPerformanceItem(content, 'Visual Zoom', `${zoomFactor.toFixed(2)}x`, zoomFactor * 100, 200);
            
            // Performance recommendations
            if (performanceData.fps.current < 20) {
                addPerformanceItem(content, 'RECOMMENDATION', 'Double-click FPS counter for performance mode', 100, 100);
            }
            
            // Add refresh button for canvas optimization
            const refreshButton = document.createElement('button');
            refreshButton.textContent = 'Force Canvas Optimization';
            refreshButton.style.cssText = `
                background: #b83400;
                color: white;
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                margin-top: 10px;
                width: 100%;
            `;
            refreshButton.onclick = () => {
                setupCanvas();
                generatePerformanceReport();
            };
            content.appendChild(refreshButton);
            
            addPerformanceItem(content, 'User Agent', navigator.userAgent.substring(0, 50) + '...', 100, 100);
        }

        function addPerformanceItem(container, label, value, current, max) {
            const item = document.createElement('div');
            item.className = 'performance-item';
            
            const percentage = Math.min((current / max) * 100, 100);
            
            if (percentage > 80) {
                item.classList.add('critical');
            } else if (percentage > 60) {
                item.classList.add('warning');
            } else {
                item.classList.add('good');
            }

            item.innerHTML = `
                <div class="performance-label">${label}</div>
                <div class="performance-value">${value}</div>
                <div class="performance-bar">
                    <div class="performance-bar-fill" style="width: ${percentage}%"></div>
                </div>
            `;
            
            container.appendChild(item);
        }

        // Popup controls
        document.getElementById('fpsCounter').addEventListener('click', () => {
            generatePerformanceReport();
            document.getElementById('performancePopup').classList.add('show');
            document.getElementById('popupOverlay').classList.add('show');
        });

        document.getElementById('closePopup').addEventListener('click', () => {
            document.getElementById('performancePopup').classList.remove('show');
            document.getElementById('popupOverlay').classList.remove('show');
        });

        document.getElementById('popupOverlay').addEventListener('click', () => {
            document.getElementById('performancePopup').classList.remove('show');
            document.getElementById('popupOverlay').classList.remove('show');
        });

        // Performance mode toggle
        let performanceMode = false;
        
        // Add performance mode button to FPS counter
        document.getElementById('fpsCounter').addEventListener('dblclick', () => {
            performanceMode = !performanceMode;
            if (performanceMode) {
                // Enable performance mode - reduce zoom for better performance
                const ultraMaxWidth = 1200;
                const ultraMaxHeight = 800;
                
                canvas.width = ultraMaxWidth * (window.devicePixelRatio || 1);
                canvas.height = ultraMaxHeight * (window.devicePixelRatio || 1);
                
                // Calculate reduced zoom for performance mode
                const screenWidth = window.innerWidth - 40;
                const screenHeight = window.innerHeight - 100;
                const scaleX = screenWidth / ultraMaxWidth;
                const scaleY = screenHeight / ultraMaxHeight;
                const zoomFactor = Math.min(scaleX, scaleY, 1.5); // Reduced zoom cap for performance
                
                canvas.style.width = (ultraMaxWidth * zoomFactor) + 'px';
                canvas.style.height = (ultraMaxHeight * zoomFactor) + 'px';
                
                fpsElement.style.color = '#ff6600';
                fpsElement.textContent = `FPS: ${performanceData.fps.current} (PERF MODE)`;

            } else {
                // Disable performance mode - restore normal size
                setupCanvas();
                fpsElement.style.color = '#00ff00';

            }
        });
        
        // Function to maintain zoom
        function maintainZoom() {
            if (canvas.dataset.zoomFactor) {
                const zoomFactor = parseFloat(canvas.dataset.zoomFactor);
                const baseWidth = 1500;
                const baseHeight = 900;
                const expectedWidth = (baseWidth * zoomFactor) + 'px';
                const expectedHeight = (baseHeight * zoomFactor) + 'px';
                
                // Reapply zoom if it was reset
                if (canvas.style.width !== expectedWidth || canvas.style.height !== expectedHeight) {
                    canvas.style.width = expectedWidth;
                    canvas.style.height = expectedHeight;

                }
            }
        }
        
        // Start monitoring
        updateFPS();
        updatePerformanceData();
        
        // Debug: Watch for canvas style changes
        const canvasObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && (mutation.attributeName === 'style')) {
                    // Debug logging removed for performance
                }
            });
        });
        
        canvasObserver.observe(canvas, { attributes: true, attributeFilter: ['style'] });
        
        // Don't maintain zoom automatically - let it be set once and stay
        // setInterval(maintainZoom, 1000);
    </script>
</body>
</html> 
</html> 